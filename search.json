[{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"project-overview","dir":"","previous_headings":"","what":"Project Overview","title":"CLAUDE.md","text":"vecshift package R package performs temporal data analysis operations employment/labor data. main function vecshift() processes data.table objects containing employment records start/end dates transforms continuous temporal segments employment status classifications overlap consolidation identifiers (over_id). Note: Analytics visualization capabilities moved companion package longworkR located ../longworkR.","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"package-split-architecture","dir":"","previous_headings":"","what":"Package Split Architecture","title":"CLAUDE.md","text":"project now split two complementary packages:","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"vecshift-core-data-transformation","dir":"","previous_headings":"Package Split Architecture","what":"vecshift (Core Data Transformation)","title":"CLAUDE.md","text":"Location: Current directory Purpose: Core temporal data processing transformation Key Components: - vecshift(): Main transformation function - classify_employment_status(): Employment status classification - add_external_events(): External event integration - add_unemployment_tail(): Unemployment period handling - merge_consecutive_employment(): Employment consolidation - process_employment_pipeline(): Pipeline processing - Data quality validation functions","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"longworkr-analytics--visualization","dir":"","previous_headings":"Package Split Architecture","what":"longworkR (Analytics & Visualization)","title":"CLAUDE.md","text":"Location: ../longworkR Purpose: Advanced analytics visualization vecshift output Key Components: - Survival Analysis: Contract survival analysis visualization - Impact Evaluation: , PSM, event studies, RDD - Network Analysis: Employment transition networks - Visualization: ggraph, g6r, interactive visualizations - Advanced Analytics: Consolidated period analysis, transition matrices","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"build-and-check-vecshift-package","dir":"","previous_headings":"Development Commands","what":"Build and Check vecshift Package","title":"CLAUDE.md","text":"","code":"# Build the package R CMD build .  # Check the package R CMD check vecshift_*.tar.gz  # Install the package locally R CMD INSTALL ."},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"build-and-check-longworkr-package","dir":"","previous_headings":"Development Commands","what":"Build and Check longworkR Package","title":"CLAUDE.md","text":"","code":"# Navigate to longworkR directory cd ../longworkR  # Build the package R CMD build .  # Check the package R CMD check longworkR_*.tar.gz  # Install the package locally R CMD INSTALL ."},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"managing-dependencies-with-renv","dir":"","previous_headings":"Development Commands","what":"Managing Dependencies with renv","title":"CLAUDE.md","text":"","code":"# For vecshift renv::restore() renv::snapshot()  # For longworkR (separate renv environment) cd ../longworkR renv::init() renv::install(\"../vecshift\")  # Install local vecshift renv::snapshot()"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"main-function-vecshift","dir":"","previous_headings":"Core Architecture","what":"Main Function: vecshift()","title":"CLAUDE.md","text":"Location: R/vecshift.R vecshift() function transforms employment records temporal segments using modular architecture: Core Transformation: Takes data.table columns: id, cf (fiscal code), INIZIO (start date), FINE (end date), prior (employment type indicator) Event Processing: Creates interval boundaries splitting record start/end events Temporal Logic: Creates end events FINE, adjusts unemployment periods (inizio+1, fine-1) Overlap Calculation: Calculates overlapping employment periods (arco) Consolidation Assignment: Generates over_id identify continuous overlapping employment periods Duration Correction: Ensures mathematical invariant elapsed time equals sum durations cf Status Classification (optional): Delegates classify_employment_status() employment state labeling Key Parameters: - classify_status (default: TRUE): Apply employment status classification - status_rules (default: NULL): Custom classification rules Output Columns: - over_id: Consolidation identifier overlapping employment periods - over_id = 0: Unemployment periods - over_id > 0: Employment periods (value contracts continuous overlapping time) - durata: Corrected duration ensuring temporal consistency - arco: Number overlapping contracts point time","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"status-classification-module","dir":"","previous_headings":"Core Architecture","what":"Status Classification Module","title":"CLAUDE.md","text":"Location: R/status_labeling.R employment status attribution handled dedicated module: - classify_employment_status(): Applies status labels temporal segments - get_default_status_rules(): Returns default classification rules - create_custom_status_rules(): Creates custom classification schemes - analyze_status_patterns(): Analyzes employment patterns - validate_status_classifications(): Validates classification integrity","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"key-dependencies","dir":"","previous_headings":"Core Architecture","what":"Key Dependencies","title":"CLAUDE.md","text":"data.table: Core data manipulation (required vecshift function) renv: Dependency management","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"data-flow","dir":"","previous_headings":"Core Architecture","what":"Data Flow","title":"CLAUDE.md","text":"Input: Employment records temporal boundaries Processing: Event-based transformation detect overlaps gaps Output: Continuous temporal segments employment status classification Analytics: Use longworkR package advanced analysis","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"typical-workflow","dir":"","previous_headings":"Working with Both Packages","what":"Typical Workflow","title":"CLAUDE.md","text":"","code":"# 1. Load packages library(vecshift) library(longworkR)  # 2. Process data with vecshift processed_data <- vecshift(   employment_data,   classify_status = TRUE )  # 3. Perform analytics with longworkR transitions <- analyze_employment_transitions(   processed_data,   consolidation_type = \"both\" )  # 4. Visualize with longworkR plot_transitions_network(transitions)"},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"development-workflow","dir":"","previous_headings":"Working with Both Packages","what":"Development Workflow","title":"CLAUDE.md","text":"developing features span packages: Core Changes: Modify vecshift data processing changes Analytics Changes: Modify longworkR new analysis methods Testing: Test integration packages Documentation: Update package docs needed","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"important-notes","dir":"","previous_headings":"","what":"Important Notes","title":"CLAUDE.md","text":"package split maintains backward compatibility clear dependencies vecshift focuses performance-critical data transformation longworkR provides flexible analytics without impacting core performance packages use renv dependency management Prior values: 0 -1 indicate part-time, positive values indicate full-time employment function handles overlapping employment periods (multiple concurrent jobs) over_id Innovation: Unique consolidation system continuous employment period analysis Duration Invariant: Mathematical guarantee elapsed_time = sum(durata) person Date Logic: Creates end events FINE adjusts unemployment periods afterward (inizio+1, fine-1)","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"migration-notes","dir":"","previous_headings":"","what":"Migration Notes","title":"CLAUDE.md","text":"existing code using combined package: Install packages: vecshift longworkR Add library(longworkR) scripts using analytics functions core data processing functions remain vecshift visualization analytics functions now longworkR Function names signatures remain unchanged","code":""},{"path":"https://gmontaletti.github.io/vecshift/CLAUDE.html","id":"reference-directory","dir":"","previous_headings":"","what":"Reference Directory","title":"CLAUDE.md","text":"Use ../reference/vecshift directory store artifacts like: - Todo lists - .md documents - Test R scripts needed compile package - Development notes scratch files using agent-r-project-maintainer, instruct move files instead deleting . - licence mit - project author mantainer Giampaolo Montaletti, giampaolo.montaletti@gmail.com, github.com/gmontaletti, ORCID https://orcid.org/0009-0002-5327-1122","code":""},{"path":"https://gmontaletti.github.io/vecshift/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Giampaolo Montaletti Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Employment Status Classification in vecshift","text":"vecshift package implements modular approach employment status classification, separating core temporal transformation logic business rules determine employment status labels. vignette explains status classification system works customize specific needs.","code":""},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"architecture-overview","dir":"Articles","previous_headings":"","what":"Architecture Overview","title":"Employment Status Classification in vecshift","text":"vecshift package follows clear separation concerns: Core Transformation (vecshift()): Handles event-based temporal logic Status Classification (classify_employment_status()): Applies employment status labels Custom Rules (create_custom_status_rules()): Defines business-specific classifications modular design ensures: - Core performance remains optimized (~1.46M records/second) - Status rules can customized without modifying core logic - Different business contexts can use different classification schemes","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"understanding-employment-states","dir":"Articles","previous_headings":"Default Status Classification","what":"Understanding Employment States","title":"Employment Status Classification in vecshift","text":"default classification recognizes several employment states based arco (overlap count) prior (employment type) values:","code":"# View default classification rules default_rules <- get_default_status_rules()  # Print the structure of default rules cat(\"Default Employment Status Categories:\\n\\n\") #> Default Employment Status Categories:  cat(\"1. Unemployment (arco = 0):\\n\") #> 1. Unemployment (arco = 0): cat(\"   - disoccupato: No active contracts\\n\\n\") #>    - disoccupato: No active contracts  cat(\"2. Single Employment (arco = 1):\\n\") #> 2. Single Employment (arco = 1): cat(\"   - occ_ft: Full-time employment (prior = 1)\\n\") #>    - occ_ft: Full-time employment (prior = 1) cat(\"   - occ_pt: Part-time employment (prior = 0)\\n\\n\") #>    - occ_pt: Part-time employment (prior = 0)  cat(\"3. Overlapping Employment (arco > 1):\\n\") #> 3. Overlapping Employment (arco > 1): cat(\"   - over_pt_ft: Transition from part-time to full-time\\n\") #>    - over_pt_ft: Transition from part-time to full-time cat(\"   - over_ft_pt: Transition from full-time to part-time\\n\") #>    - over_ft_pt: Transition from full-time to part-time cat(\"   - over_pt_pt: Multiple part-time employments\\n\") #>    - over_pt_pt: Multiple part-time employments cat(\"   - over_ft_ft: Multiple full-time employments\\n\") #>    - over_ft_ft: Multiple full-time employments"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"example-with-default-classification","dir":"Articles","previous_headings":"Default Status Classification","what":"Example with Default Classification","title":"Employment Status Classification in vecshift","text":"","code":"# Create sample employment data with various scenarios sample_data <- data.table(   id = 1:5,   cf = c(\"P001\", \"P001\", \"P001\", \"P002\", \"P002\"),   inizio = as.Date(c(\"2023-01-01\", \"2023-03-01\", \"2023-07-01\",                       \"2023-02-01\", \"2023-05-01\")),   fine = as.Date(c(\"2023-02-28\", \"2023-06-30\", \"2023-12-31\",                     \"2023-04-30\", \"2023-08-31\")),   prior = c(1, 0, 1, 1, 0)  # Mix of full-time and part-time )  print(\"Input employment data:\") #> [1] \"Input employment data:\" print(sample_data) #>       id     cf     inizio       fine prior #>    <int> <char>     <Date>     <Date> <num> #> 1:     1   P001 2023-01-01 2023-02-28     1 #> 2:     2   P001 2023-03-01 2023-06-30     0 #> 3:     3   P001 2023-07-01 2023-12-31     1 #> 4:     4   P002 2023-02-01 2023-04-30     1 #> 5:     5   P002 2023-05-01 2023-08-31     0  # Apply vecshift transformation vecshift_result <- vecshift(sample_data)  # Apply status classification as separate step result <- classify_employment_status(vecshift_result)  print(\"\\nProcessed segments with status classification:\") #> [1] \"\\nProcessed segments with status classification:\" print(result[, .(cf, inizio, fine, arco, prior, stato, durata)]) #>        cf     inizio       fine  arco prior  stato     durata #>    <char>     <Date>     <Date> <num> <num> <char> <difftime> #> 1:   P001 2023-01-01 2023-02-28     1     1     ft    59 days #> 2:   P001 2023-03-01 2023-06-30     1     0     pt   122 days #> 3:   P001 2023-07-01 2023-12-31     1     1     ft   184 days #> 4:   P002 2023-02-01 2023-04-30     1     1     ft    89 days #> 5:   P002 2023-05-01 2023-08-31     1     0     pt   123 days"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"creating-custom-rules","dir":"Articles","previous_headings":"Customizing Status Classification","what":"Creating Custom Rules","title":"Employment Status Classification in vecshift","text":"can create custom classification rules different business contexts:","code":"# Example 1: Custom rules for a specific industry industry_rules <- create_custom_status_rules(   unemployment_threshold = 15,  # Different threshold for unemployment   custom_labels = list(     unemployed_short = \"temporary_layoff\",     unemployed_long = \"permanent_layoff\",     full_time = \"regular_employee\",     part_time = \"contractor\"   ) )  # Apply custom rules vecshift_result <- vecshift(sample_data) result_custom <- classify_employment_status(vecshift_result, rules = industry_rules)  print(\"Results with custom industry rules:\") print(result_custom[, .(cf, stato, durata)])"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"advanced-custom-rules","dir":"Articles","previous_headings":"Customizing Status Classification","what":"Advanced Custom Rules","title":"Employment Status Classification in vecshift","text":"complex scenarios, can create sophisticated rule sets:","code":"# Create rules with intensity and transition tracking advanced_rules <- create_custom_status_rules(   unemployment_threshold = 30,   custom_labels = list(     unemployed_short = \"job_transition\",     unemployed_long = \"career_break\",     full_time = \"permanent_staff\",     part_time = \"flexible_work\",     overlap_pt_ft = \"upgrading_hours\",     overlap_ft_pt = \"reducing_hours\",     overlap_pt_pt = \"multiple_gigs\",     overlap_ft_ft = \"dual_employment\"   ),   include_intensity = TRUE,   include_transitions = TRUE )  # Process with advanced rules vecshift_result <- vecshift(sample_data) result_advanced <- classify_employment_status(vecshift_result, rules = advanced_rules)  print(\"Results with advanced classification:\") unique_states <- unique(result_advanced$stato) cat(\"Unique employment states found:\", paste(unique_states, collapse = \", \"), \"\\n\")"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"processing-without-status-classification","dir":"Articles","previous_headings":"","what":"Processing Without Status Classification","title":"Employment Status Classification in vecshift","text":"Sometimes may want work raw temporal segments without status labels:","code":"# Process without status classification raw_segments <- vecshift(sample_data)  print(\"Raw segments without status labels:\") print(raw_segments[, .(cf, inizio, fine, arco, prior, durata)])  # You can apply classification later if needed classified_later <- classify_employment_status(raw_segments)  print(\"\\nStatus added separately:\") print(classified_later[, .(cf, inizio, fine, stato)])"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"analyzing-status-patterns","dir":"Articles","previous_headings":"","what":"Analyzing Status Patterns","title":"Employment Status Classification in vecshift","text":"package includes tools analyzing employment status patterns:","code":"# Generate more complex data for pattern analysis complex_data <- data.table(   id = 1:10,   cf = rep(c(\"P001\", \"P002\", \"P003\"), c(4, 3, 3)),   inizio = as.Date(c(\"2023-01-01\", \"2023-04-01\", \"2023-07-01\", \"2023-10-01\",                       \"2023-02-01\", \"2023-06-01\", \"2023-09-01\",                       \"2023-03-01\", \"2023-05-01\", \"2023-11-01\")),   fine = as.Date(c(\"2023-03-31\", \"2023-06-30\", \"2023-09-30\", \"2023-12-31\",                     \"2023-05-31\", \"2023-08-31\", \"2023-12-31\",                     \"2023-04-30\", \"2023-10-31\", \"2023-12-31\")),   prior = c(1, 0, 1, 0, 1, 1, 0, 0, 1, 1) )  # Process and analyze patterns vecshift_result <- vecshift(complex_data) result_complex <- classify_employment_status(vecshift_result) patterns <- analyze_status_patterns(result_complex, include_transitions = TRUE)  # Display pattern analysis print(patterns) #> Employment Status Pattern Analysis #> ================================= #>  #> Status Distribution: #> ------------------- #> ft             :      6 (60.0%) #> pt             :      4 (40.0%) #>  #> Average Duration by Status: #> --------------------------- #> ft             :  106.5 days (6 segments) #> pt             :   91.5 days (4 segments) #>  #> Employment Quality Indicators: #> ----------------------------- #> Continuous Employment Rate: 100.0% #> Average Segments per Person: 3.3 #> Overlap Prevalence: 0.0% #> Overall Employment Concentration: 100.0% #>  #> Most Common Transitions: #> ----------------------- #> ft->pt                   : 3 #> ft->ft                   : 2 #> pt->ft                   : 2"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"validating-status-classifications","dir":"Articles","previous_headings":"","what":"Validating Status Classifications","title":"Employment Status Classification in vecshift","text":"Ensure integrity status classifications:","code":"# Validate status classifications validation <- validate_status_classifications(result_complex)  print(validation) #> Employment Status Validation Results #> =================================== #>  #> [WARNING] Status classification issues detected #> Validation Rate: 100.0% #>  #> Issue Summary: #> ------------- #> Missing Labels: 0 #> Impossible Combinations: 0 #>  #> Unexpected Status Labels: #> ft, pt  #>  #> Missing Critical Status Labels: #> unemployment  # Check for specific issues if (!validation$is_valid) {   cat(\"\\nValidation issues detected:\\n\")    if (validation$missing_labels > 0) {     cat(\"- Missing labels:\", validation$missing_labels, \"\\n\")   }    if (validation$total_impossible > 0) {     cat(\"- Impossible combinations:\", validation$total_impossible, \"\\n\")      # Show details of impossible combinations     for (issue in names(validation$impossible_combinations)) {       count <- validation$impossible_combinations[[issue]]       if (count > 0) {         cat(\"  *\", gsub(\"_\", \" \", issue), \":\", count, \"\\n\")       }     }   } } #>  #> Validation issues detected:"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"working-with-data-quality-module","dir":"Articles","previous_headings":"Integration with Other Modules","what":"Working with Data Quality Module","title":"Employment Status Classification in vecshift","text":"","code":"# Check data quality before processing quality_assessment <- assess_data_quality(complex_data)  # Check if data has quality issues (using production readiness as indicator) if (!is.null(quality_assessment$quality_score$is_production_ready) &&     !quality_assessment$quality_score$is_production_ready) {   cat(\"Data quality issues detected. Cleaning data...\\n\")    # Clean data if needed   clean_data <- clean_employment_data(     complex_data,     remove_duplicates = TRUE,     remove_invalid_dates = TRUE   )    # Process cleaned data   result_clean <- vecshift(clean_data) } else {   cat(\"Data quality check passed.\\n\")   result_clean <- vecshift(complex_data) }"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"using-the-integrated-system","dir":"Articles","previous_headings":"Integration with Other Modules","what":"Using the Integrated System","title":"Employment Status Classification in vecshift","text":"comprehensive processing modules:","code":"# Use the integrated system for full processing pipeline integrated_result <- process_employment_pipeline(   complex_data,   classify_status = TRUE,   show_progress = FALSE )  # Access different components of the result cat(\"Processing summary:\\n\") cat(\"- Output rows:\", nrow(integrated_result), \"\\n\") cat(\"- Status labels applied:\", \"stato\" %in% names(integrated_result), \"\\n\")"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"choosing-the-right-approach","dir":"Articles","previous_headings":"Performance Considerations","what":"Choosing the Right Approach","title":"Employment Status Classification in vecshift","text":"Different scenarios call different approaches: High-volume production: Use vecshift() default settings Custom business rules: Use vecshift() custom status rules Development/debugging: Use process_employment_pipeline() verbose output Raw processing: Use vecshift() directly maximum speed (apply status classification separately needed)","code":"# Example: Benchmarking different approaches library(microbenchmark)  # Generate large dataset large_data <- data.table(   id = 1:10000,   cf = rep(paste0(\"P\", 1:1000), each = 10),   inizio = as.Date(\"2020-01-01\") + sample(0:1000, 10000, replace = TRUE),   fine = as.Date(\"2020-01-01\") + sample(100:1100, 10000, replace = TRUE),   prior = sample(0:1, 10000, replace = TRUE) )  # Benchmark different approaches benchmark_results <- microbenchmark(   vecshift_only = vecshift(large_data),   with_status = {vecshift_result <- vecshift(large_data); classify_employment_status(vecshift_result)},   custom_rules = {vecshift_result <- vecshift(large_data); classify_employment_status(vecshift_result, rules = industry_rules)},   times = 10 )  print(benchmark_results)"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"choose-appropriate-classification-rules","dir":"Articles","previous_headings":"Best Practices","what":"1. Choose Appropriate Classification Rules","title":"Employment Status Classification in vecshift","text":"Select rules match business context: - Financial sector: May need detailed overlap tracking - Government statistics: May use standardized unemployment thresholds - HR analytics: May focus employment transitions","code":""},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"validate-classifications","dir":"Articles","previous_headings":"Best Practices","what":"2. Validate Classifications","title":"Employment Status Classification in vecshift","text":"Always validate classifications, especially custom rules:","code":"# Good practice: Always validate after custom classification vecshift_result <- vecshift(sample_data) custom_result <- classify_employment_status(vecshift_result, rules = industry_rules) validation <- validate_status_classifications(custom_result, rules = industry_rules)  if (validation$is_valid) {   cat(\"Classification validated successfully\\n\") } else {   cat(\"Warning: Classification validation failed\\n\") }"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"document-custom-rules","dir":"Articles","previous_headings":"Best Practices","what":"3. Document Custom Rules","title":"Employment Status Classification in vecshift","text":"creating custom rules, document business logic:","code":"# Example: Well-documented custom rules seasonal_employment_rules <- create_custom_status_rules(   unemployment_threshold = 60,  # Seasonal workers may have longer gaps   custom_labels = list(     unemployed_short = \"off_season\",      # Normal seasonal gap     unemployed_long = \"extended_break\",   # Longer than typical seasonal gap     full_time = \"peak_season_ft\",         # Peak season full-time     part_time = \"shoulder_season_pt\",     # Shoulder season part-time     overlap_pt_pt = \"multi_seasonal\",     # Multiple seasonal jobs     overlap_ft_ft = \"peak_double_shift\"   # Peak season multiple full-time   ) )  # Document the rules cat(\"Seasonal Employment Classification Rules:\\n\") cat(\"- Off-season gaps up to 60 days are normal\\n\") cat(\"- Multiple overlapping jobs common during peak season\\n\") cat(\"- Part-time work typical during shoulder seasons\\n\")"},{"path":"https://gmontaletti.github.io/vecshift/articles/status-classification.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Employment Status Classification in vecshift","text":"vecshift status classification system provides: Separation Concerns: Core logic separate status rules Flexibility: Easy customization different contexts Performance: impact core processing speed Validation: Built-tools ensure classification integrity Analytics: Pattern analysis quality assessment tools Key functions status classification: - vecshift(): Main function optional classification - classify_employment_status(): Apply status labels segments - create_custom_status_rules(): Define custom classification schemes - analyze_status_patterns(): Analyze employment patterns - validate_status_classifications(): Ensure classification integrity modular approach ensures vecshift can adapt various business requirements maintaining high-performance core.","code":""},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Understanding Date Logic in vecshift","text":"vecshift package processes employment records temporal data, transforming continuous time segments employment status classifications. heart transformation lies precise date logic ensures accurate calculation employment unemployment periods. vignette explains updated date handling rules new version vecshift, deprecated FINE+1 logic favor simpler, intuitive approach.","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"inclusive-contract-periods","dir":"Articles","previous_headings":"Core Date Logic Principles","what":"1. Inclusive Contract Periods","title":"Understanding Date Logic in vecshift","text":"Employment contracts vecshift treated inclusive date ranges: Contract duration: INIZIO FINE (days included) Person works: start date end date","code":"# Example: January contract contract_start <- as.Date(\"2023-01-01\") contract_end <- as.Date(\"2023-01-31\")  # Calculate duration duration <- as.numeric(contract_end - contract_start + 1) cat(\"Contract duration:\", duration, \"days\\n\") #> Contract duration: 31 days cat(\"Person works from:\", format(contract_start, \"%B %d\"),      \"to\", format(contract_end, \"%B %d\"), \"(both days inclusive)\\n\") #> Person works from: January 01 to January 31 (both days inclusive)"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"the-date-logic","dir":"Articles","previous_headings":"Core Date Logic Principles","what":"2. The Date Logic","title":"Understanding Date Logic in vecshift","text":"Approach: vecshift implementation creates end events FINE adjusts unemployment periods afterward. logic: - End events created contract end date (FINE) - Unemployment segments (arco=0) identified event processing - Unemployment dates adjusted: inizio+1 fine-1 - maintains temporal accuracy simpler logic","code":"# Example: Contract ends January 31st contract_end <- as.Date(\"2023-01-31\") # The end event is at FINE event_date <- contract_end # Unemployment adjustment happens during processing unemployment_start <- contract_end + 1  # Still starts Feb 1 after adjustment  cat(\"Last day of work:\", format(contract_end, \"%B %d, %Y\"), \"\\n\") #> Last day of work: January 31, 2023 cat(\"End event created at:\", format(event_date, \"%B %d, %Y\"), \"\\n\") #> End event created at: January 31, 2023 cat(\"First day unemployed (after adjustment):\", format(unemployment_start, \"%B %d, %Y\"), \"\\n\") #> First day unemployed (after adjustment): February 01, 2023"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"event-based-transformation","dir":"Articles","previous_headings":"Core Date Logic Principles","what":"3. Event-Based Transformation","title":"Understanding Date Logic in vecshift","text":"vecshift converts employment contract exactly two events: Start Event: Date = INIZIO, Value = +1 End Event: Date = FINE (FINE+1 new version), Value = -1","code":"# Create sample employment data employment_data <- data.table(   id = 1:2,   cf = c(\"PERSON001\", \"PERSON001\"),   inizio = as.Date(c(\"2023-01-01\", \"2023-04-01\")),   fine = as.Date(c(\"2023-03-31\", \"2023-06-30\")),   prior = c(1, 0) )  print(\"Original employment data:\") #> [1] \"Original employment data:\" print(employment_data) #>       id        cf     inizio       fine prior #>    <int>    <char>     <Date>     <Date> <num> #> 1:     1 PERSON001 2023-01-01 2023-03-31     1 #> 2:     2 PERSON001 2023-04-01 2023-06-30     0  # The new vecshift creates events at FINE (not FINE+1) # End events now occur ON the contract end date cat(\"\\nIn the new logic:\\n\") #>  #> In the new logic: cat(\"- End events are created at FINE\\n\") #> - End events are created at FINE cat(\"- Unemployment periods are adjusted afterward (inizio+1, fine-1)\\n\") #> - Unemployment periods are adjusted afterward (inizio+1, fine-1)"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"scenario-1-consecutive-contracts-no-gap","dir":"Articles","previous_headings":"Practical Examples","what":"Scenario 1: Consecutive Contracts (No Gap)","title":"Understanding Date Logic in vecshift","text":"","code":"consecutive_data <- data.table(   id = 1:2,   cf = rep(\"PERSON001\", 2),   inizio = as.Date(c(\"2023-01-01\", \"2023-04-01\")),   fine = as.Date(c(\"2023-03-31\", \"2023-06-30\")),   prior = c(1, 0) )  print(\"Consecutive contracts:\") #> [1] \"Consecutive contracts:\" print(consecutive_data) #>       id        cf     inizio       fine prior #>    <int>    <char>     <Date>     <Date> <num> #> 1:     1 PERSON001 2023-01-01 2023-03-31     1 #> 2:     2 PERSON001 2023-04-01 2023-06-30     0  # Check if there's unemployment between contracts first_end <- consecutive_data$fine[1] second_start <- consecutive_data$inizio[2] gap_duration <- as.numeric(second_start - first_end - 1)  cat(\"\\nFirst contract ends:\", format(first_end, \"%B %d\"), \"\\n\") #>  #> First contract ends: March 31 cat(\"Second contract starts:\", format(second_start, \"%B %d\"), \"\\n\") #> Second contract starts: April 01 cat(\"Unemployment duration:\", gap_duration, \"days\\n\") #> Unemployment duration: 0 days  if (gap_duration == 0) {   cat(\"No unemployment gap - contracts are consecutive!\\n\") } #> No unemployment gap - contracts are consecutive!"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"scenario-2-gap-between-contracts","dir":"Articles","previous_headings":"Practical Examples","what":"Scenario 2: Gap Between Contracts","title":"Understanding Date Logic in vecshift","text":"","code":"gap_data <- data.table(   id = 1:2,   cf = rep(\"PERSON001\", 2),   inizio = as.Date(c(\"2023-01-01\", \"2023-03-15\")),   fine = as.Date(c(\"2023-02-28\", \"2023-05-31\")),   prior = c(1, 0) )  print(\"Contracts with gap:\") #> [1] \"Contracts with gap:\" print(gap_data) #>       id        cf     inizio       fine prior #>    <int>    <char>     <Date>     <Date> <num> #> 1:     1 PERSON001 2023-01-01 2023-02-28     1 #> 2:     2 PERSON001 2023-03-15 2023-05-31     0  # Calculate unemployment period first_end <- gap_data$fine[1] second_start <- gap_data$inizio[2] gap_duration <- as.numeric(second_start - first_end - 1)  unemployment_start <- first_end + 1 unemployment_end <- second_start - 1  cat(\"\\nFirst contract ends:\", format(first_end, \"%B %d\"), \"\\n\") #>  #> First contract ends: February 28 cat(\"Unemployment period:\", format(unemployment_start, \"%B %d\"), \"to\",      format(unemployment_end, \"%B %d\"), \"\\n\") #> Unemployment period: March 01 to March 14 cat(\"Second contract starts:\", format(second_start, \"%B %d\"), \"\\n\") #> Second contract starts: March 15 cat(\"Total unemployment days:\", gap_duration, \"\\n\") #> Total unemployment days: 14"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"scenario-3-overlapping-contracts","dir":"Articles","previous_headings":"Practical Examples","what":"Scenario 3: Overlapping Contracts","title":"Understanding Date Logic in vecshift","text":"","code":"overlap_data <- data.table(   id = 1:2,   cf = rep(\"PERSON001\", 2),   inizio = as.Date(c(\"2023-01-01\", \"2023-03-01\")),   fine = as.Date(c(\"2023-06-30\", \"2023-04-30\")),   prior = c(1, 0) )  print(\"Overlapping contracts:\") #> [1] \"Overlapping contracts:\" print(overlap_data) #>       id        cf     inizio       fine prior #>    <int>    <char>     <Date>     <Date> <num> #> 1:     1 PERSON001 2023-01-01 2023-06-30     1 #> 2:     2 PERSON001 2023-03-01 2023-04-30     0  # The vecshift function would generate events at these dates cat(\"\\nEvents would be created at:\\n\") #>  #> Events would be created at: cat(\"- Contract 1 start:\", format(overlap_data$inizio[1]), \"(+1)\\n\") #> - Contract 1 start: 2023-01-01 (+1) cat(\"- Contract 1 end:\", format(overlap_data$fine[1]), \"(-1)\\n\") #> - Contract 1 end: 2023-06-30 (-1) cat(\"- Contract 2 start:\", format(overlap_data$inizio[2]), \"(+1)\\n\") #> - Contract 2 start: 2023-03-01 (+1) cat(\"- Contract 2 end:\", format(overlap_data$fine[2]), \"(-1)\\n\") #> - Contract 2 end: 2023-04-30 (-1)  # The cumulative sum would show overlapping employment cat(\"\\nCumulative employment levels (arco):\\n\") #>  #> Cumulative employment levels (arco): cat(\"- Before March 1: arco = 1 (single employment)\\n\") #> - Before March 1: arco = 1 (single employment) cat(\"- March 1 - April 30: arco = 2 (overlapping employment)\\n\") #> - March 1 - April 30: arco = 2 (overlapping employment) cat(\"- May 1 - June 30: arco = 1 (single employment)\\n\") #> - May 1 - June 30: arco = 1 (single employment)  # Identify overlap period overlap_start <- overlap_data$inizio[2] overlap_end <- min(overlap_data$fine) cat(\"\\nOverlapping period:\", format(overlap_start, \"%B %d\"), \"to\",      format(overlap_end, \"%B %d\"), \"\\n\") #>  #> Overlapping period: March 01 to April 30 cat(\"During this period: arco = 2 (multiple employment)\\n\") #> During this period: arco = 2 (multiple employment)"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"employment-vs-unemployment-duration","dir":"Articles","previous_headings":"Duration Calculations","what":"Employment vs Unemployment Duration","title":"Understanding Date Logic in vecshift","text":"Duration calculations differ based employment status due event structure:","code":"# Create data with both employment and unemployment periods mixed_data <- data.table(   id = 1:2,   cf = rep(\"PERSON001\", 2),   inizio = as.Date(c(\"2023-01-01\", \"2023-04-01\")),   fine = as.Date(c(\"2023-02-28\", \"2023-06-30\")),   prior = c(1, 0) )  # Calculate employment durations (inclusive) emp_duration_1 <- as.numeric(mixed_data$fine[1] - mixed_data$inizio[1] + 1) emp_duration_2 <- as.numeric(mixed_data$fine[2] - mixed_data$inizio[2] + 1)  # Calculate unemployment duration unemp_duration <- as.numeric(mixed_data$inizio[2] - mixed_data$fine[1] - 1)  cat(\"Employment periods:\\n\") #> Employment periods: cat(\"  Contract 1:\", emp_duration_1, \"days (Jan 1 - Feb 28, inclusive)\\n\") #>   Contract 1: 59 days (Jan 1 - Feb 28, inclusive) cat(\"  Contract 2:\", emp_duration_2, \"days (Apr 1 - Jun 30, inclusive)\\n\") #>   Contract 2: 91 days (Apr 1 - Jun 30, inclusive) cat(\"\\nUnemployment period:\", unemp_duration, \"days (Mar 1 - Mar 31)\\n\") #>  #> Unemployment period: 31 days (Mar 1 - Mar 31)  # Verify total coverage total_days <- as.numeric(max(mixed_data$fine) - min(mixed_data$inizio) + 1) accounted_days <- emp_duration_1 + emp_duration_2 + unemp_duration cat(\"\\nTotal period:\", total_days, \"days\\n\") #>  #> Total period: 181 days cat(\"Accounted for:\", accounted_days, \"days\\n\") #> Accounted for: 181 days cat(\"Complete coverage:\", total_days == accounted_days, \"\\n\") #> Complete coverage: TRUE"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"common-date-issues","dir":"Articles","previous_headings":"Data Quality and Validation","what":"Common Date Issues","title":"Understanding Date Logic in vecshift","text":"date logic module includes comprehensive validation detect common problems:","code":"# Create data with various quality issues problem_data <- data.table(   id = 1:4,   cf = rep(\"PERSON001\", 4),   inizio = as.Date(c(\"2023-01-01\", \"2023-03-01\", \"2023-05-01\", \"2023-07-15\")),   fine = as.Date(c(\"2023-02-28\", \"2023-02-15\", \"2023-05-01\", \"2023-07-10\")),  # Issues!   prior = c(1, 0, 1, 0) )  print(\"Data with quality issues:\") #> [1] \"Data with quality issues:\" print(problem_data) #>       id        cf     inizio       fine prior #>    <int>    <char>     <Date>     <Date> <num> #> 1:     1 PERSON001 2023-01-01 2023-02-28     1 #> 2:     2 PERSON001 2023-03-01 2023-02-15     0 #> 3:     3 PERSON001 2023-05-01 2023-05-01     1 #> 4:     4 PERSON001 2023-07-15 2023-07-10     0  # Basic validation can be done with simple R operations cat(\"\\nValidation Results:\\n\") #>  #> Validation Results: invalid_ranges <- sum(problem_data$fine < problem_data$inizio, na.rm = TRUE) zero_duration <- sum(problem_data$fine == problem_data$inizio, na.rm = TRUE) cat(\"Invalid date ranges:\", invalid_ranges, \"\\n\") #> Invalid date ranges: 2 cat(\"Zero duration contracts:\", zero_duration, \"\\n\") #> Zero duration contracts: 1  # Identify specific problems invalid_rows <- which(problem_data$fine < problem_data$inizio) zero_duration_rows <- which(problem_data$fine == problem_data$inizio)  if (length(invalid_rows) > 0) {   cat(\"\\nInvalid ranges (FINE < INIZIO) in rows:\", invalid_rows, \"\\n\") } #>  #> Invalid ranges (FINE < INIZIO) in rows: 2 4 if (length(zero_duration_rows) > 0) {   cat(\"Zero duration contracts in rows:\", zero_duration_rows, \"\\n\") } #> Zero duration contracts in rows: 3"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"using-vecshift-for-analysis","dir":"Articles","previous_headings":"Data Quality and Validation","what":"Using vecshift for Analysis","title":"Understanding Date Logic in vecshift","text":"","code":"# Analyze employment patterns using vecshift clean_data <- data.table(   id = 1:3,   cf = rep(\"PERSON001\", 3),   inizio = as.Date(c(\"2023-01-01\", \"2023-04-01\", \"2023-07-01\")),   fine = as.Date(c(\"2023-03-31\", \"2023-05-31\", \"2023-09-30\")),   prior = c(1, 0, 1) )  # Use vecshift to create temporal segments result <- vecshift(clean_data)  print(\"Temporal segments with employment status:\") #> [1] \"Temporal segments with employment status:\" print(result) #>           cf     inizio       fine  arco prior    id over_id     durata #>       <char>     <Date>     <Date> <num> <num> <int>   <int> <difftime> #> 1: PERSON001 2023-01-01 2023-03-31     1     1     1       1    90 days #> 2: PERSON001 2023-04-01 2023-05-31     1     0     2       2    61 days #> 3: PERSON001 2023-06-01 2023-06-30     0     0     0       0    30 days #> 4: PERSON001 2023-07-01 2023-09-30     1     1     3       3    92 days  # Calculate employment statistics total_duration <- as.numeric(sum(result$durata)) employment_duration <- as.numeric(sum(result$durata[result$arco > 0])) employment_rate <- employment_duration / total_duration  cat(\"\\nEmployment statistics:\\n\") #>  #> Employment statistics: cat(\"Employment rate:\", round(employment_rate, 3), \"\\n\") #> Employment rate: 0.89 cat(\"Total segments:\", nrow(result), \"\\n\") #> Total segments: 4"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"core-function-with-status-classification","dir":"Articles","previous_headings":"Integration with vecshift Processing","what":"Core Function with Status Classification","title":"Understanding Date Logic in vecshift","text":"main vecshift function now separates core temporal logic status classification:","code":"# Example data employment_data <- data.table(   id = 1:3,   cf = c(\"P001\", \"P001\", \"P002\"),   inizio = as.Date(c(\"2023-01-01\", \"2023-06-01\", \"2023-02-01\")),   fine = as.Date(c(\"2023-05-31\", \"2023-12-31\", \"2023-11-30\")),   prior = c(1, 0, 1) )  # Process with default status classification result_with_status <- vecshift(employment_data) print(result_with_status[1:5]) #>        cf     inizio       fine  arco prior    id over_id     durata #>    <char>     <Date>     <Date> <num> <num> <int>   <int> <difftime> #> 1:   P001 2023-01-01 2023-05-31     1     1     1       1   151 days #> 2:   P001 2023-06-01 2023-12-31     1     0     2       2   214 days #> 3:   P002 2023-02-01 2023-11-30     1     1     3       3   303 days #> 4:   <NA>       <NA>       <NA>    NA    NA    NA      NA    NA days #> 5:   <NA>       <NA>       <NA>    NA    NA    NA      NA    NA days  # Process without status classification (raw segments only) result_raw <- vecshift(employment_data) print(result_raw[1:5]) #>        cf     inizio       fine  arco prior    id over_id     durata #>    <char>     <Date>     <Date> <num> <num> <int>   <int> <difftime> #> 1:   P001 2023-01-01 2023-05-31     1     1     1       1   151 days #> 2:   P001 2023-06-01 2023-12-31     1     0     2       2   214 days #> 3:   P002 2023-02-01 2023-11-30     1     1     3       3   303 days #> 4:   <NA>       <NA>       <NA>    NA    NA    NA      NA    NA days #> 5:   <NA>       <NA>       <NA>    NA    NA    NA      NA    NA days"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"custom-status-classification","dir":"Articles","previous_headings":"Integration with vecshift Processing","what":"Custom Status Classification","title":"Understanding Date Logic in vecshift","text":"Status attribution now handled dedicated classify_employment_status function: separation ensures: - Core date logic remains optimized unchanged - Status classification can customized independently - Clear separation concerns maintainability","code":"# Create custom classification rules custom_rules <- create_custom_status_rules(   unemployment_threshold = 30,  # Longer threshold   custom_labels = list(     unemployed_short = \"job_seeking\",     unemployed_long = \"long_term_unemployed\"   ) )  # Apply custom classification result_custom <- vecshift_result <- vecshift(employment_data) result_custom <- classify_employment_status(vecshift_result, rules = custom_rules)"},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"always-validate-input-data","dir":"Articles","previous_headings":"Best Practices","what":"1. Always Validate Input Data","title":"Understanding Date Logic in vecshift","text":"","code":"# Before processing, always check data quality has_invalid_dates <- any(employment_data$FINE < employment_data$INIZIO, na.rm = TRUE)  if (has_invalid_dates) {   warning(\"Date issues detected - review data before processing\") }"},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"handle-different-date-formats","dir":"Articles","previous_headings":"Best Practices","what":"2. Handle Different Date Formats","title":"Understanding Date Logic in vecshift","text":"","code":"# vecshift expects Date objects - convert if needed numeric_dates <- c(19358, 19387)  # Days since 1970-01-01 char_dates <- c(\"2023-01-01\", \"2023-01-30\")  # Convert to Date objects dates_from_numeric <- as.Date(numeric_dates, origin = \"1970-01-01\") dates_from_char <- as.Date(char_dates)  print(\"Date conversions:\") #> [1] \"Date conversions:\" print(list(from_numeric = dates_from_numeric,             from_character = dates_from_char)) #> $from_numeric #> [1] \"2023-01-01\" \"2023-01-30\" #>  #> $from_character #> [1] \"2023-01-01\" \"2023-01-30\""},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"understand-the-business-context","dir":"Articles","previous_headings":"Best Practices","what":"3. Understand the Business Context","title":"Understanding Date Logic in vecshift","text":"vecshift date logic reflects real-world employment patterns: Legal/Administrative: Employment contracts typically end “end day” FINE Benefits: Unemployment benefits often start day employment ends Taxation: Tax calculations need precise employment period boundaries Analysis: Labor statistics require continuous temporal coverage","code":""},{"path":"https://gmontaletti.github.io/vecshift/articles/understanding-date-logic.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Understanding Date Logic in vecshift","text":"vecshift date logic ensures: Temporal Continuity: Every day classified either employed unemployed Precision: FINE+1 logic eliminates ambiguity unemployment start dates Flexibility: Handles consecutive, overlapping, gap scenarios correctly Validation: Comprehensive quality checks prevent common date errors Performance: Optimized large-scale employment datasets Modularity: Status classification separate core temporal logic Key architectural principles: - Core Logic: main vecshift() function handles event-based temporal transformation - Status Attribution: classify_employment_status() function applies employment labels - Customization: Status rules can modified without touching core date logic - Performance: Core transformation remains optimized ~1.46M records/second Understanding date logic crucial : - Correctly interpreting vecshift results - Debugging unexpected outputs - Extending package functionality - Creating custom status classification rules - Integrating temporal analysis tools vecshift architecture ensures consistent date logic allowing flexible customization business rules status classifications integrated status labeling system.","code":""},{"path":"https://gmontaletti.github.io/vecshift/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Giampaolo Montaletti. Author, maintainer.","code":""},{"path":"https://gmontaletti.github.io/vecshift/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Montaletti, G. (2025). vecshift: Temporal Analysis Employment Data Event-Based Processing. R package version 1.0.0. https://github.com/gmontaletti/vecshift","code":"@Manual{,   title = {vecshift: Temporal Analysis of Employment Data with Event-Based Processing},   author = {Giampaolo Montaletti},   year = {2025},   note = {R package version 1.0.0},   url = {https://github.com/gmontaletti/vecshift}, }"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"vecshift","dir":"","previous_headings":"","what":"vecshift: Temporal Analysis of Employment Data","title":"vecshift: Temporal Analysis of Employment Data","text":"“Time line, dimension - employment periods overlap, interweave, transform tapestry working life.” R package temporal data analysis employment records. vecshift package transforms employment data overlapping time periods continuous temporal segments employment status classifications.","code":""},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"vecshift: Temporal Analysis of Employment Data","text":"vecshift package provides efficient tools processing employment/labor data stored data.table format. handles complex scenarios including: Multiple concurrent employment periods Employment gaps detection Part-time vs full-time classification Overlapping job periods main function vecshift() uses advanced data.table operations efficient processing large datasets.","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"from-github","dir":"","previous_headings":"Installation","what":"From GitHub","title":"vecshift: Temporal Analysis of Employment Data","text":"","code":"# Install devtools if you haven't already install.packages(\"devtools\")  # Install vecshift from GitHub devtools::install_github(\"gmontaletti/vecshift\")"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"local-development","dir":"","previous_headings":"Installation","what":"Local Development","title":"vecshift: Temporal Analysis of Employment Data","text":"","code":"# Clone the repository git clone https://github.com/gmontaletti/vecshift.git cd vecshift  # Install the package locally R CMD INSTALL ."},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"vecshift: Temporal Analysis of Employment Data","text":"","code":"library(vecshift) library(data.table)  # Prepare your employment data # Required columns: id, cf (fiscal code), INIZIO (start date), FINE (end date), prior (employment type) employment_data <- data.table(   id = 1:3,   cf = c(\"ABC123\", \"ABC123\", \"DEF456\"),   INIZIO = as.Date(c(\"2020-01-01\", \"2020-06-01\", \"2020-03-01\")),   FINE = as.Date(c(\"2020-12-31\", \"2021-05-31\", \"2020-09-30\")),   prior = c(1, 0, 1)  # 0/-1 for part-time, positive for full-time )  # Apply the vecshift transformation result <- vecshift(employment_data)"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"output-format","dir":"","previous_headings":"","what":"Output Format","title":"vecshift: Temporal Analysis of Employment Data","text":"function returns data.table continuous temporal segments containing: periodo: Time period identifier cf: Fiscal code data_inizio: Segment start date data_fine: Segment end date disoccupato: Unemployed periods occ_ft: Full-time employment occ_pt: Part-time employment over_*: Overlapping employment situations","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"dependencies","dir":"","previous_headings":"Development","what":"Dependencies","title":"vecshift: Temporal Analysis of Employment Data","text":"package uses renv dependency management. set development environment:","code":"# Restore project dependencies renv::restore()  # After adding new dependencies install.packages(\"new_package\") renv::snapshot()"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"building-and-testing","dir":"","previous_headings":"Development","what":"Building and Testing","title":"vecshift: Temporal Analysis of Employment Data","text":"","code":"# Build the package R CMD build .  # Check the package R CMD check vecshift_*.tar.gz  # Run tests Rscript tests/test.R"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"documentation","dir":"","previous_headings":"Development","what":"Documentation","title":"vecshift: Temporal Analysis of Employment Data","text":"","code":"# Generate documentation from roxygen comments devtools::document()  # Build package documentation devtools::build_manual()"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"requirements","dir":"","previous_headings":"","what":"Requirements","title":"vecshift: Temporal Analysis of Employment Data","text":"R (>= 4.0.0) data.table (>= 1.14.0)","code":""},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"vecshift: Temporal Analysis of Employment Data","text":"use vecshift research publications, please cite follows: BibTeX entry: APA format: Montaletti, G. (2025). vecshift: Temporal Analysis Employment Data Event-Based Processing (Version 1.0.3) [Computer software]. https://github.com/gmontaletti/vecshift","code":"# To get citation information in R: citation(\"vecshift\") @Manual{vecshift2025,   title = {vecshift: Temporal Analysis of Employment Data with Event-Based Processing},   author = {Giampaolo Montaletti},   year = {2025},   note = {R package version 1.0.3},   url = {https://github.com/gmontaletti/vecshift},   doi = {10.5281/zenodo.XXXXXXX} }"},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"vecshift: Temporal Analysis of Employment Data","text":"project licensed MIT License - see LICENSE.md file details.","code":""},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"vecshift: Temporal Analysis of Employment Data","text":"Giampaolo Montaletti 📧 giampaolo.montaletti@gmail.com 🔗 GitHub 🆔 ORCID: 0009-0002-5327-1122","code":""},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"vecshift: Temporal Analysis of Employment Data","text":"Contributions welcome! Please feel free submit Pull Request.","code":""},{"path":"https://gmontaletti.github.io/vecshift/index.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"vecshift: Temporal Analysis of Employment Data","text":"encounter problems suggestions, please file issue https://github.com/gmontaletti/vecshift/issues","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":null,"dir":"Reference","previous_headings":"","what":"Add External Event Attributes to Unemployment Periods — add_external_events","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"Adds external event attributes unemployment periods vecshift output matching events unemployment segments (arco == 0). Events matched using either temporal overlap nearest neighbor strategies. function can also create synthetic unemployment periods persons present external events main employment data.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"","code":"add_external_events(   vecshift_data,   external_events,   event_matching_strategy = c(\"overlap\", \"nearest\"),   create_synthetic_unemployment = FALSE,   synthetic_unemployment_duration = 730L,   date_columns = c(start = \"event_start\", end = \"event_end\"),   event_name_column = \"event_name\",   person_id_column = \"cf\",   memory_safe = FALSE,   chunk_size = 10000L,   progress = FALSE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"vecshift_data data.table output vecshift() containing temporal employment segments required columns: cf, inizio, fine, arco, prior, id, over_id, durata. Optional: stato column employment status. external_events data.table containing external events person identifiers event information. Must contain person_id_column event_name_column, plus least one date column specified date_columns. event_matching_strategy Character. Matching strategy use: \"overlap\": Match events temporally overlap unemployment periods \"nearest\": Find nearest unemployment period overlap exists create_synthetic_unemployment Logical. Whether create synthetic unemployment periods persons external_events vecshift_data (default: FALSE). synthetic_unemployment_duration Integer. Maximum duration days synthetic unemployment periods (default: 730L 2 years). date_columns Named character vector specifying date column names external_events. Names \"start\" optionally \"end\". Default: c(start = \"event_start\", end = \"event_end\"). event_name_column Character. Name column external_events containing event names/types (default: \"event_name\"). person_id_column Character. Name column external_events containing person identifiers match 'cf' column vecshift_data (default: \"cf\"). memory_safe Logical. Enable memory-safe mode large datasets. TRUE, processes data chunks reduce peak memory usage cost performance (default: FALSE). chunk_size Integer. Number persons process per chunk memory_safe = TRUE (default: 10000L). progress Logical. Show progress messages long-running operations (default: FALSE).","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"data.table structure vecshift_data, extended : New columns: \"event_name_attribute\" (1 matched unemployment periods, 0 otherwise) New columns: \"event_name_distance\" (days event unemployment period) New columns: \"event_name_match_quality\" (overlap, nearest, none) Synthetic unemployment periods create_synthetic_unemployment = TRUE Maintains original ordering cf temporal sequence.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"function implements two matching strategies: Overlap matching: Events temporally overlap unemployment periods Nearest matching: overlap exists, finds nearest unemployment period external event, function: Creates new column \"event_name_attribute\" value 1 matched periods Adds distance/quality metrics additional columns Maintains original vecshift data integrity Handles multiple events per person Synthetic Unemployment Creation: create_synthetic_unemployment = TRUE, function creates unemployment periods persons external_events vecshift_data: Creates periods synthetic_unemployment_duration days Uses max(fine) main dataset reference endpoint Follows vecshift formatting conventions Memory Optimization: function includes several memory optimization strategies: -place modifications using data.table reference semantics Chunked processing large datasets memory_safe = TRUE Early filtering reduce intermediate object sizes Efficient rolling joins nearest neighbor matching Immediate cleanup temporary objects","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"function optimizes performance using data.table operations follows vecshift coding conventions. handles edge cases : Events start dates (treated single-day events) Multiple events per person Persons unemployment periods Date format consistency datasets Proper integration over_id consolidation logic large datasets (>1M records), consider using memory_safe = TRUE enable chunked processing reduces peak memory usage.","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/reference/add_external_events.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add External Event Attributes to Unemployment Periods — add_external_events","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table)  # Create sample employment data employment_dt <- data.table(   id = 1:3,   cf = c(\"ABC123\", \"ABC123\", \"DEF456\"),   INIZIO = as.Date(c(\"2023-01-01\", \"2023-07-01\", \"2023-03-01\")),   FINE = as.Date(c(\"2023-03-31\", \"2023-12-31\", \"2023-06-30\")),   prior = c(1, 1, 0) )  # Transform to vecshift format vecshift_result <- vecshift(employment_dt)  # Create external events (e.g., training programs) training_events <- data.table(   cf = c(\"ABC123\", \"DEF456\", \"GHI789\"),   event_name = c(\"training_program\", \"training_program\", \"training_program\"),   event_start = as.Date(c(\"2023-05-15\", \"2023-08-01\", \"2023-04-01\")),   event_end = as.Date(c(\"2023-05-25\", \"2023-08-15\", \"2023-04-15\")) )  # Add external events with overlap matching result_with_events <- add_external_events(   vecshift_data = vecshift_result,   external_events = training_events,   event_matching_strategy = \"overlap\",   date_columns = c(start = \"event_start\", end = \"event_end\"),   event_name_column = \"event_name\" )  # Check the new attribute columns print(result_with_events[, .(cf, arco, training_program_attribute,                               training_program_distance, training_program_match_quality)])  # Add events with synthetic unemployment for missing persons result_with_synthetic <- add_external_events(   vecshift_data = vecshift_result,   external_events = training_events,   event_matching_strategy = \"overlap\",   create_synthetic_unemployment = TRUE,   synthetic_unemployment_duration = 365L )  # Use nearest neighbor matching when overlap is not sufficient result_nearest <- add_external_events(   vecshift_data = vecshift_result,   external_events = training_events,   event_matching_strategy = \"nearest\" )  # For very large datasets, use memory-safe mode result_large <- add_external_events(   vecshift_data = large_vecshift_result,   external_events = large_training_events,   event_matching_strategy = \"overlap\",   memory_safe = TRUE,   chunk_size = 5000L,   progress = TRUE ) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"Extends vecshift output adding unemployment periods beginning /end employment histories. creates complete temporal coverage analysis requiring uniform observation periods : Head: Adding unemployment min_date first employment start Tail: Adding unemployment last employment end max_date","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"","code":"add_unemployment_periods(   vecshift_data,   min_date = NULL,   max_date = NULL,   min_duration = 1L,   add_head = FALSE,   add_tail = TRUE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"vecshift_data data.table output vecshift() containing temporal employment segments required columns: cf, inizio, fine, arco, prior, id, over_id, durata. Optional: stato column employment status. min_date Date numeric. start date unemployment heads (optional). used add_head = TRUE. Individuals first employment starting date get unemployment heads added. max_date Date numeric. end date unemployment tails (optional). used add_tail = TRUE. Individuals last employment ending date get unemployment tails added. min_duration Integer. Minimum duration days unemployment periods added. Shorter periods excluded (default: 1). add_head Logical. Whether add unemployment periods beginning employment histories (default: FALSE). Requires min_date specified. add_tail Logical. Whether add unemployment periods end employment histories (default: TRUE). Requires max_date specified.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"data.table structure input, extended   unemployment tail segments applicable. Maintains original ordering   cf temporal sequence.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"function can add unemployment periods ends employment histories: Head Unemployment (add_head = TRUE): Identifies individuals whose first employment starts min_date Creates unemployment min_date (first_start - 1) added duration >= min_duration Tail Unemployment (add_tail = TRUE): Identifies individuals whose last employment ends max_date Creates unemployment (last_end + 1) max_date added duration >= min_duration unemployment periods follow vecshift formatting: arco = 0: active employment contracts over_id = 0: Unemployment period id = 0: associated contract ID prior = 0: Standard unemployment periods durata: Correctly calculated duration stato = \"disoccupato\": Employment status (present input) function preserves temporal invariant elapsed time equals sum durations person, ensuring consistency vecshift's core logic.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"function optimized performance using data.table operations follows vecshift coding conventions. handles edge cases : Individuals already starting /min_date (head added) Individuals already ending /max_date (tail added) short unemployment periods (filtered min_duration) Proper integration over_id consolidation logic Maintains temporal ordering cf inizio","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_periods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Unemployment Periods at the Beginning and End of Employment Histories — add_unemployment_periods","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) # Create sample employment data dt <- data.table(   id = 1:2,   cf = c(\"ABC123\", \"DEF456\"),   INIZIO = as.Date(c(\"2023-03-01\", \"2023-06-01\")),   FINE = as.Date(c(\"2023-05-31\", \"2023-08-31\")),   prior = c(1, 0) )  # Transform to vecshift format result <- vecshift(dt)  # Add unemployment tails only (backward compatible) extended_result <- add_unemployment_periods(   result,    max_date = as.Date(\"2024-12-31\") )  # Add unemployment heads only extended_result <- add_unemployment_periods(   result,   min_date = as.Date(\"2022-01-01\"),   add_head = TRUE,   add_tail = FALSE )  # Add both head and tail unemployment extended_result <- add_unemployment_periods(   result,   min_date = as.Date(\"2022-01-01\"),   max_date = as.Date(\"2024-12-31\"),   add_head = TRUE,   add_tail = TRUE )  # Check the added unemployment periods print(extended_result[arco == 0]) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_tail.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Unemployment Periods at the End of Employment Histories (Legacy) — add_unemployment_tail","title":"Add Unemployment Periods at the End of Employment Histories (Legacy) — add_unemployment_tail","text":"function maintained backward compatibility. calls new \\codeadd_unemployment_periods() function \\codeadd_tail = TRUE \\codeadd_head = FALSE.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_tail.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Unemployment Periods at the End of Employment Histories (Legacy) — add_unemployment_tail","text":"","code":"add_unemployment_tail(vecshift_data, max_date, min_tail_duration = 1L)"},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_tail.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Unemployment Periods at the End of Employment Histories (Legacy) — add_unemployment_tail","text":"vecshift_data data.table output vecshift() max_date Date numeric. end date unemployment tails min_tail_duration Integer. Minimum duration unemployment tails (default: 1)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/add_unemployment_tail.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Unemployment Periods at the End of Employment Histories (Legacy) — add_unemployment_tail","text":"data.table unemployment tail periods added","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_status_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze Employment Status Patterns — analyze_status_patterns","title":"Analyze Employment Status Patterns — analyze_status_patterns","text":"Analyzes patterns employment status classifications provide insights employment dynamics, stability, transition frequencies.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_status_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze Employment Status Patterns — analyze_status_patterns","text":"","code":"analyze_status_patterns(   classified_data,   person_col = \"cf\",   include_transitions = TRUE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_status_patterns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze Employment Status Patterns — analyze_status_patterns","text":"classified_data Data.table employment segments stato column person_col Name person identifier column (default: \"cf\") include_transitions Logical. Include transition analysis","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_status_patterns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze Employment Status Patterns — analyze_status_patterns","text":"List pattern analysis results","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_temporal_clustering.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze Temporal Clustering Patterns — analyze_temporal_clustering","title":"Analyze Temporal Clustering Patterns — analyze_temporal_clustering","text":"Detects patterns contract timing seasonal employment, batch processing indicators, systematic data collection periods.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_temporal_clustering.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze Temporal Clustering Patterns — analyze_temporal_clustering","text":"","code":"analyze_temporal_clustering(dt, person_col = \"cf\")"},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_temporal_clustering.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze Temporal Clustering Patterns — analyze_temporal_clustering","text":"dt Data.table employment records person_col Person identifier column name","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/analyze_temporal_clustering.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze Temporal Clustering Patterns — analyze_temporal_clustering","text":"List temporal clustering analysis","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/assess_data_quality.html","id":null,"dir":"Reference","previous_headings":"","what":"Comprehensive Data Quality Assessment — assess_data_quality","title":"Comprehensive Data Quality Assessment — assess_data_quality","text":"Performs exhaustive data quality analysis including missing values, duplicates, outliers, temporal patterns, logical inconsistencies. Generates detailed quality report recommendations. Includes validation over_id consistency duration calculation invariant.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/assess_data_quality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comprehensive Data Quality Assessment — assess_data_quality","text":"","code":"assess_data_quality(   dt,   person_col = \"cf\",   include_distributions = TRUE,   include_temporal = TRUE,   validate_over_id = TRUE,   validate_duration = TRUE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/assess_data_quality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comprehensive Data Quality Assessment — assess_data_quality","text":"dt Data.table employment records (standardized columns) person_col Name person identifier column include_distributions Logical. Include distribution analysis include_temporal Logical. Include temporal pattern analysis validate_over_id Logical. Include over_id consistency checks validate_duration Logical. Include duration invariant validation","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/assess_data_quality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Comprehensive Data Quality Assessment — assess_data_quality","text":"List comprehensive quality assessment results","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/check_pipeline_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Pipeline Function Availability — check_pipeline_functions","title":"Check Pipeline Function Availability — check_pipeline_functions","text":"Utility function check pipeline functions available current environment. helps users understand pipeline steps can executed.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/check_pipeline_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Pipeline Function Availability — check_pipeline_functions","text":"","code":"check_pipeline_functions()"},{"path":"https://gmontaletti.github.io/vecshift/reference/check_pipeline_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Pipeline Function Availability — check_pipeline_functions","text":"named logical vector indicating functions available: vecshift: Core transformation function merge_original_columns: Column merging function merge_overlapping_values: Overlap handling function merge_consecutive_employment: Period consolidation over_id merge_consecutive_employment_fast: Traditional consecutive merging","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/check_pipeline_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Pipeline Function Availability — check_pipeline_functions","text":"","code":"if (FALSE) { # \\dontrun{ # Check which functions are available availability <- check_pipeline_functions() print(availability)  # Use availability to conditionally run pipeline steps if (availability[\"merge_original_columns\"]) {   # Can safely merge columns } } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/classify_employment_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Employment Status Classification — classify_employment_status","title":"Apply Employment Status Classification — classify_employment_status","text":"Classifies employment segments using flexible, customizable rules support numeric prior value system. Features sequence-based overlap labeling creates descriptive labels based chronological employment types. Optimized high-performance processing minimal memory allocations.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/classify_employment_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Employment Status Classification — classify_employment_status","text":"","code":"classify_employment_status(   segments,   rules = get_default_status_rules(),   group_by = \"cf\",   show_progress = FALSE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/classify_employment_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Employment Status Classification — classify_employment_status","text":"segments Data.table temporal segments containing arco, prior, durata columns rules List classification rules (default: get_default_status_rules()) group_by Character vector columns group shift operations (default: \"cf\") show_progress Logical indicating whether show progress bar (default: FALSE)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/classify_employment_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Employment Status Classification — classify_employment_status","text":"Data.table stato column containing employment status labels","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/classify_employment_status.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Apply Employment Status Classification — classify_employment_status","text":"**Key Enhancements**: 1. **Flexible Prior Value Mapping**: longer normalizes prior values.    Supports numeric employment type codes custom prior_labels. 2. **Sequence-Based Overlap Labeling**: overlapping employment periods,    creates labels based chronological sequence employment types.    Example: prior values [0, 1, 2] sequence -> \"over_pt_ft_fixed\" 3. **Unknown Prior Handling**: unmapped prior values, uses numeric    labels (e.g., \"occ_5\" unknown prior value 5). 4. **Backward Compatibility**: Maintains compatibility existing    prior value conventions supporting new flexible mapping. **Performance Optimizations**: * Vectorized data.table operations replace sapply() calls * Pre-allocated memory string concatenation * -place modifications using := operator * Optimized grouping operations large datasets * Optional progress tracking long-running operations **Classification Logic**: * **Unemployment** (arco = 0): Labeled based duration threshold * **Single Employment** (arco = 1): \"occ_\" + employment type label * **Overlapping Employment** (arco > 1): \"over_\" + sequence types","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/classify_employment_status.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply Employment Status Classification — classify_employment_status","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) # Sample segments data with various prior values segments <- data.table(   cf = rep(\"A001\", 6),   inizio = 1:6,   fine = 2:7,   arco = c(0, 1, 2, 2, 1, 0),   prior = c(NA, 1, 0, 2, 5, NA),  # Note: prior=5 is unmapped   durata = rep(1, 6),   over_id = c(0, 1, 2, 2, 3, 0) )  # Apply default classification with progress tracking classified <- classify_employment_status(segments, show_progress = TRUE) print(classified$stato) # Result: \"disoccupato\", \"occ_ft\", \"over_pt_fixed\", \"over_pt_fixed\", \"occ_5\", \"disoccupato\"  # Use custom prior labels for industry-specific codes custom_rules <- create_custom_status_rules(   prior_labels = list(     \"0\" = \"parttime\",     \"1\" = \"fulltime\",     \"2\" = \"contract\",     \"5\" = \"apprentice\"  # Map the previously unknown value   ) ) classified_custom <- classify_employment_status(segments, custom_rules) print(classified_custom$stato) # Result: \"disoccupato\", \"occ_fulltime\", \"over_parttime_contract\", #         \"over_parttime_contract\", \"occ_apprentice\", \"disoccupato\"  # Example showing sequence-based labeling with multiple overlap types overlap_data <- data.table(   cf = \"B002\",   inizio = 1:4,   fine = 2:5,   arco = c(1, 3, 3, 2),   prior = c(0, 1, 2, 3),   durata = rep(1, 4),   over_id = c(1, 2, 2, 2) )  classified_overlap <- classify_employment_status(overlap_data) print(classified_overlap$stato) # Result: \"occ_pt\", \"over_ft_fixed_temp\", \"over_ft_fixed_temp\", \"over_ft_fixed_temp\" } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/clean_employment_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Clean Employment Data — clean_employment_data","title":"Clean Employment Data — clean_employment_data","text":"Applies automatic data cleaning procedures address common data quality issues. Includes options handling missing values, duplicates, logical inconsistencies.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/clean_employment_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clean Employment Data — clean_employment_data","text":"","code":"clean_employment_data(   dt,   remove_duplicates = TRUE,   remove_invalid_dates = TRUE,   remove_zero_duration = FALSE,   fill_missing_prior = TRUE,   verbose = TRUE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/clean_employment_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clean Employment Data — clean_employment_data","text":"dt Data.table employment records remove_duplicates Logical. Remove duplicate records remove_invalid_dates Logical. Remove records invalid date ranges remove_zero_duration Logical. Remove zero-duration contracts fill_missing_prior Logical. Fill missing prior values mode verbose Logical. Print cleaning summary","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/clean_employment_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clean Employment Data — clean_employment_data","text":"Cleaned data.table cleaning summary attribute","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/create_custom_status_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Custom Status Classification Rules — create_custom_status_rules","title":"Create Custom Status Classification Rules — create_custom_status_rules","text":"Helper function create custom employment status classification rules specific business contexts analytical requirements. Supports flexible prior value mappings different employment coding systems.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/create_custom_status_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Custom Status Classification Rules — create_custom_status_rules","text":"","code":"create_custom_status_rules(   unemployment_threshold = 8,   custom_labels = NULL,   prior_labels = NULL,   include_intensity = FALSE,   include_transitions = FALSE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/create_custom_status_rules.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Custom Status Classification Rules — create_custom_status_rules","text":"unemployment_threshold Days threshold short vs long unemployment (default: 8) custom_labels Named list custom status labels override defaults prior_labels Named list mapping prior values employment type labels. Keys string representations prior values, values corresponding employment type labels. Example: list(\"0\" = \"pt\", \"1\" = \"ft\", \"2\" = \"fixed\", \"5\" = \"intern\") include_intensity Logical. Include employment intensity classifications include_transitions Logical. Include transition-based classifications","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/create_custom_status_rules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Custom Status Classification Rules — create_custom_status_rules","text":"List custom classification rules compatible classify_employment_status()","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/create_custom_status_rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Custom Status Classification Rules — create_custom_status_rules","text":"**Key Features**: 1. **Custom Prior Labels**: Map numeric prior values meaningful labels.    enables support industry-specific organization-specific    employment type coding systems. 2. **Flexible Thresholds**: Customize unemployment duration thresholds    based analytical requirements policy definitions. 3. **Custom Label Systems**: Override default status labels match    organizational terminology reporting requirements. 4. **Extension Support**: Include additional classification dimensions    like employment intensity transition-based classifications. **Prior Labels Usage**: prior_labels parameter crucial enhanced flexible system. maps string representations prior values employment type labels used final status classifications.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/create_custom_status_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Custom Status Classification Rules — create_custom_status_rules","text":"","code":"# Basic custom rules with industry-specific employment types healthcare_rules <- create_custom_status_rules(   unemployment_threshold = 15,  # 15 days for healthcare sector   prior_labels = list(     \"0\" = \"parttime\",     \"1\" = \"fulltime\",     \"2\" = \"locum\",      # Temporary medical staff     \"3\" = \"agency\",     # Agency workers     \"4\" = \"oncall\"      # On-call staff   ) )  # Advanced rules with custom labels and extended mappings academic_rules <- create_custom_status_rules(   unemployment_threshold = 90,  # Longer periods common in academia   custom_labels = list(     unemployed_short = \"between_positions\",     unemployed_long = \"career_transition\"   ),   prior_labels = list(     \"1\" = \"tenured\",     \"2\" = \"tenure_track\",     \"3\" = \"adjunct\",     \"4\" = \"postdoc\",     \"5\" = \"visiting\",     \"10\" = \"emeritus\"   ),   include_intensity = TRUE )  # Demonstrate the effect of custom prior labels if (FALSE) { # \\dontrun{ library(data.table) segments <- data.table(   cf = \"PROF001\",   inizio = c(1, 30, 60),   fine = c(29, 59, 90),   arco = c(1, 0, 2),   prior = c(2, NA, 4),  # tenure_track, unemployment, postdoc   durata = c(29, 30, 31),   over_id = c(1, 0, 2) )  classified <- classify_employment_status(segments, academic_rules) print(classified$stato) # Expected: \"occ_tenure_track\", \"between_positions\", \"occ_postdoc\" } # }  # Legacy system compatibility - mapping old codes to new labels legacy_rules <- create_custom_status_rules(   prior_labels = list(     \"100\" = \"manager\",     \"200\" = \"supervisor\",     \"300\" = \"specialist\",     \"400\" = \"trainee\",     \"999\" = \"consultant\"   ) )"},{"path":"https://gmontaletti.github.io/vecshift/reference/data_quality.html","id":null,"dir":"Reference","previous_headings":"","what":"Data Quality and Validation Module — data_quality","title":"Data Quality and Validation Module — data_quality","text":"Comprehensive data quality assessment validation employment records. Provides flexible column mapping, data type validation, logical consistency checks, detailed quality reporting employment temporal analysis.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-classify_with_consolidated_overlaps.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify Employment Status with Consolidated Overlaps — .classify_with_consolidated_overlaps","title":"Classify Employment Status with Consolidated Overlaps — .classify_with_consolidated_overlaps","text":"Internal function provides consolidated classification overlapping employment periods using over_id grouping. creates single status labels entire overlapping employment periods rather segment--segment classification.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-classify_with_consolidated_overlaps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify Employment Status with Consolidated Overlaps — .classify_with_consolidated_overlaps","text":"","code":".classify_with_consolidated_overlaps(segments, rules, group_by)"},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-classify_with_consolidated_overlaps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify Employment Status with Consolidated Overlaps — .classify_with_consolidated_overlaps","text":"segments Data.table employment segments including over_id column rules Classification rules group_by Character vector grouping columns","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-classify_with_consolidated_overlaps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify Employment Status with Consolidated Overlaps — .classify_with_consolidated_overlaps","text":"Data.table consolidated employment status classifications","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-create_synthetic_unemployment.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Synthetic Unemployment Periods for Missing Persons — .create_synthetic_unemployment","title":"Create Synthetic Unemployment Periods for Missing Persons — .create_synthetic_unemployment","text":"Internal helper function create synthetic unemployment periods persons present external events main employment data.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-create_synthetic_unemployment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Synthetic Unemployment Periods for Missing Persons — .create_synthetic_unemployment","text":"","code":".create_synthetic_unemployment(   vecshift_data,   events_data,   person_id_column,   max_duration,   has_stato,   date_columns )"},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-create_synthetic_unemployment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Synthetic Unemployment Periods for Missing Persons — .create_synthetic_unemployment","text":"vecshift_data Main employment data events_data External events data person_id_column Person identifier column name max_duration Maximum synthetic unemployment duration has_stato Whether stato column exists date_columns Named vector date columns","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-create_synthetic_unemployment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Synthetic Unemployment Periods for Missing Persons — .create_synthetic_unemployment","text":"Extended vecshift_data synthetic unemployment periods","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_chunked.html","id":null,"dir":"Reference","previous_headings":"","what":"Match Events Using Nearest Neighbor Strategy (Chunked for Memory Safety) — .match_events_nearest_chunked","title":"Match Events Using Nearest Neighbor Strategy (Chunked for Memory Safety) — .match_events_nearest_chunked","text":"Ultra-memory-safe chunked version processes small batches person--person aggressive memory management.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_chunked.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match Events Using Nearest Neighbor Strategy (Chunked for Memory Safety) — .match_events_nearest_chunked","text":"","code":".match_events_nearest_chunked(   vecshift_data,   events_data,   event_name_column,   person_id_column,   chunk_size,   progress = FALSE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_chunked.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match Events Using Nearest Neighbor Strategy (Chunked for Memory Safety) — .match_events_nearest_chunked","text":"vecshift_data Main employment data attribute columns initialized events_data Prepared external events data event_name_column Event name column (standardized) person_id_column Person identifier column (standardized) chunk_size Number persons process per chunk progress Show progress messages","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_chunked.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match Events Using Nearest Neighbor Strategy (Chunked for Memory Safety) — .match_events_nearest_chunked","text":"Updated vecshift_data nearest neighbor matches","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_optimized.html","id":null,"dir":"Reference","previous_headings":"","what":"Match Events Using Nearest Neighbor Strategy (Fully Vectorized) — .match_events_nearest_optimized","title":"Match Events Using Nearest Neighbor Strategy (Fully Vectorized) — .match_events_nearest_optimized","text":"Fully vectorized nearest neighbor matching using data.table operations. Eliminates nested loops using cross joins distance calculations subsequent filtering minimum distances per event-person combination.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_optimized.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match Events Using Nearest Neighbor Strategy (Fully Vectorized) — .match_events_nearest_optimized","text":"","code":".match_events_nearest_optimized(   vecshift_data,   events_data,   event_name_column,   person_id_column,   progress = FALSE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_optimized.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match Events Using Nearest Neighbor Strategy (Fully Vectorized) — .match_events_nearest_optimized","text":"vecshift_data Main employment data attribute columns initialized events_data Prepared external events data event_name_column Event name column (standardized) person_id_column Person identifier column (standardized) progress Show progress messages","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_nearest_optimized.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match Events Using Nearest Neighbor Strategy (Fully Vectorized) — .match_events_nearest_optimized","text":"Updated vecshift_data nearest neighbor matches","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_overlap_optimized.html","id":null,"dir":"Reference","previous_headings":"","what":"Match Events Using Temporal Overlap Strategy (Fully Vectorized) — .match_events_overlap_optimized","title":"Match Events Using Temporal Overlap Strategy (Fully Vectorized) — .match_events_overlap_optimized","text":"Fully vectorized implementation using data.table operations eliminate nested loops. Uses foverlaps() bulk updates vectorized case handling optimal performance large datasets.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_overlap_optimized.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match Events Using Temporal Overlap Strategy (Fully Vectorized) — .match_events_overlap_optimized","text":"","code":".match_events_overlap_optimized(   vecshift_data,   events_data,   event_name_column,   person_id_column,   progress = FALSE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_overlap_optimized.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match Events Using Temporal Overlap Strategy (Fully Vectorized) — .match_events_overlap_optimized","text":"vecshift_data Main employment data attribute columns initialized events_data Prepared external events data event_name_column Event name column (standardized) person_id_column Person identifier column (standardized) progress Show progress messages","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-match_events_overlap_optimized.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match Events Using Temporal Overlap Strategy (Fully Vectorized) — .match_events_overlap_optimized","text":"Updated vecshift_data overlap matches, row count input (plus synthetics)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-prepare_events_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare External Events Data for Matching — .prepare_events_data","title":"Prepare External Events Data for Matching — .prepare_events_data","text":"Internal helper function standardize external events data temporal matching operations.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-prepare_events_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare External Events Data for Matching — .prepare_events_data","text":"","code":".prepare_events_data(   events_data,   date_columns,   event_name_column,   person_id_column )"},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-prepare_events_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare External Events Data for Matching — .prepare_events_data","text":"events_data External events data.table date_columns Named vector date columns event_name_column Event name column person_id_column Person identifier column","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/dot-prepare_events_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare External Events Data for Matching — .prepare_events_data","text":"Prepared events data.table standardized columns","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_default_status_rules.html","id":null,"dir":"Reference","previous_headings":"","what":"Default Employment Status Classification Rules — get_default_status_rules","title":"Default Employment Status Classification Rules — get_default_status_rules","text":"Returns default classification rules used vecshift employment status. rules include flexible prior value mappings support sequence-based overlap labeling. rules can modified implement custom business logic.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_default_status_rules.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default Employment Status Classification Rules — get_default_status_rules","text":"","code":"get_default_status_rules()"},{"path":"https://gmontaletti.github.io/vecshift/reference/get_default_status_rules.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default Employment Status Classification Rules — get_default_status_rules","text":"List default classification rules containing: unemployment: Rules unemployment periods duration thresholds prior_labels: Named list mapping prior values employment type labels single_employment: Rules single employment periods overlapping_employment: Rules overlapping employment periods","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_default_status_rules.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Default Employment Status Classification Rules — get_default_status_rules","text":"default rules include: **Prior Labels Mapping**: Maps numeric prior values employment type labels: * \"-1\", \"0\" -> \"pt\" (part-time) * \"1\" -> \"ft\" (full-time) * \"2\" -> \"fixed\" (fixed-term contract) * \"3\" -> \"temp\" (temporary contract) **Unemployment Classification**: Based duration thresholds (8 days default) **Single Employment**: Creates labels like \"occ_ft\", \"occ_pt\", \"occ_fixed\" **Overlapping Employment**: Uses sequence-based labeling create labels like \"over_pt_ft_fixed\" based chronological sequence employment types within overlapping period.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_default_status_rules.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default Employment Status Classification Rules — get_default_status_rules","text":"","code":"# View default rules default_rules <- get_default_status_rules() print(default_rules) #> $unemployment #> $unemployment$condition #> [1] \"arco == 0\" #>  #> $unemployment$duration_threshold #> [1] 8 #>  #> $unemployment$short_label #> [1] \"disoccupato\" #>  #> $unemployment$long_label #> [1] \"disoccupato\" #>  #>  #> $prior_labels #> $prior_labels$`-1` #> [1] \"pt\" #>  #> $prior_labels$`0` #> [1] \"pt\" #>  #> $prior_labels$`1` #> [1] \"ft\" #>  #> $prior_labels$`2` #> [1] \"fixed\" #>  #> $prior_labels$`3` #> [1] \"temp\" #>  #>  #> $single_employment #> $single_employment$full_time #> $single_employment$full_time$condition #> [1] \"arco == 1 & prior == 1\" #>  #> $single_employment$full_time$label #> [1] \"occ_ft\" #>  #>  #> $single_employment$part_time #> $single_employment$part_time$condition #> [1] \"arco == 1 & prior == 0\" #>  #> $single_employment$part_time$label #> [1] \"occ_pt\" #>  #>  #>  #> $overlapping_employment #> $overlapping_employment$pt_to_ft #> $overlapping_employment$pt_to_ft$condition #> [1] \"arco > 1 & (prior > shift(prior, type = 'lag'))\" #>  #> $overlapping_employment$pt_to_ft$label #> [1] \"over_pt_ft\" #>  #>  #> $overlapping_employment$ft_to_pt #> $overlapping_employment$ft_to_pt$condition #> [1] \"arco > 1 & (prior < shift(prior, type = 'lag'))\" #>  #> $overlapping_employment$ft_to_pt$label #> [1] \"over_ft_pt\" #>  #>  #> $overlapping_employment$pt_to_pt #> $overlapping_employment$pt_to_pt$condition #> [1] \"arco > 1 & (prior == shift(prior, type = 'lag')) & prior == 0\" #>  #> $overlapping_employment$pt_to_pt$label #> [1] \"over_pt_pt\" #>  #>  #> $overlapping_employment$ft_to_ft #> $overlapping_employment$ft_to_ft$condition #> [1] \"default\" #>  #> $overlapping_employment$ft_to_ft$label #> [1] \"over_ft_ft\" #>  #>  #>   # Check prior labels mapping print(default_rules$prior_labels) #> $`-1` #> [1] \"pt\" #>  #> $`0` #> [1] \"pt\" #>  #> $`1` #> [1] \"ft\" #>  #> $`2` #> [1] \"fixed\" #>  #> $`3` #> [1] \"temp\" #>   # Example: prior value 2 maps to \"fixed\" print(default_rules$prior_labels[\"2\"])  # \"fixed\" #> $`2` #> [1] \"fixed\" #>"},{"path":"https://gmontaletti.github.io/vecshift/reference/get_pipeline_recommendations.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Pipeline Recommendations — get_pipeline_recommendations","title":"Get Pipeline Recommendations — get_pipeline_recommendations","text":"Analyzes input data provides recommendations optimal pipeline configuration based data characteristics available functions.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_pipeline_recommendations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Pipeline Recommendations — get_pipeline_recommendations","text":"","code":"get_pipeline_recommendations(data, target_operation = \"analysis\")"},{"path":"https://gmontaletti.github.io/vecshift/reference/get_pipeline_recommendations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Pipeline Recommendations — get_pipeline_recommendations","text":"data data.table containing employment data analyze target_operation Character string indicating intended use: \"analysis\": statistical analysis (default) \"reporting\": business reporting \"visualization\": data visualization \"export\": data export/sharing","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_pipeline_recommendations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Pipeline Recommendations — get_pipeline_recommendations","text":"list containing: recommendations: Named logical vector recommended settings merge_columns: Suggested columns merge () reasoning: Character vector explaining recommendations warnings: potential issues detected","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/get_pipeline_recommendations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Pipeline Recommendations — get_pipeline_recommendations","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table)  # Create sample data sample_data <- data.table(   id = 1:100,   cf = sample(paste0(\"PERSON\", 1:20), 100, replace = TRUE),   inizio = sample(seq(as.Date(\"2020-01-01\"), as.Date(\"2023-12-31\"), by = \"day\"), 100),   fine = inizio + sample(30:365, 100, replace = TRUE),   prior = sample(c(0, 1), 100, replace = TRUE),   company = sample(c(\"CompanyA\", \"CompanyB\", \"CompanyC\"), 100, replace = TRUE),   salary = sample(25000:80000, 100, replace = TRUE) )  # Get recommendations for analysis recs <- get_pipeline_recommendations(sample_data, \"analysis\") print(recs)  # Apply recommendations result <- process_employment_pipeline(   original_data = sample_data,   merge_columns = recs$merge_columns,   apply_vecshift = recs$recommendations[\"apply_vecshift\"],   handle_overlaps = recs$recommendations[\"handle_overlaps\"],   collapse_consecutive = recs$recommendations[\"collapse_consecutive\"] ) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Employment Periods with Multiple Consolidation Modes — merge_consecutive_employment","title":"Merge Employment Periods with Multiple Consolidation Modes — merge_consecutive_employment","text":"Merges employment periods using different consolidation strategies based over_id column vecshift() output. over_id column identifies continuous overlapping employment periods, enabling sophisticated consolidation approaches employment history analysis.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Employment Periods with Multiple Consolidation Modes — merge_consecutive_employment","text":"","code":"merge_consecutive_employment(dt, consolidation_type = \"both\")"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Employment Periods with Multiple Consolidation Modes — merge_consecutive_employment","text":"dt data.table output vecshift() containing temporal segments columns: cf: Person identifier inizio: Segment start date fine: Segment end date arco: Number overlapping contracts (0 = unemployment) prior: Employment type (numeric) over_id: Overlap identifier (0 = unemployment, >0 = overlapping periods) Additional columns: contract parameters (numeric character) consolidation_type Character string specifying consolidation approach: \"\" (DEFAULT): First consolidate overlapping periods (over_id > 0),         merge consecutive periods. Provides complete employment history consolidation. \"overlapping\": consolidate segments over_id > 0.         Merges simultaneous/overlapping contracts single periods. \"consecutive\": merge periods contiguous time,         regardless over_id. Traditional consecutive period merging. \"none\": consolidation. Returns original segments unchanged.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Employment Periods with Multiple Consolidation Modes — merge_consecutive_employment","text":"data.table consolidated employment periods containing: cf: Person identifier inizio: Period start date fine: Period end date arco: Number overlapping contracts (preserved unemployment) prior: Duration-weighted mean priority collapsed periods Character columns: Concatenated \"first->last\" collapsed periods Numeric columns: Duration-weighted mean value collapsed periods Numeric columns \"_direction\" suffix: Direction change (last - first) durata: Duration period days collapsed: Logical indicating period collapsed (TRUE) (FALSE)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge Employment Periods with Multiple Consolidation Modes — merge_consecutive_employment","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) # Create sample output from vecshift with over_id dt <- data.table(   cf = c(\"A\", \"A\", \"A\", \"A\", \"B\", \"B\"),   inizio = as.Date(c(\"2023-01-01\", \"2023-02-01\", \"2023-02-15\", \"2023-04-01\",                       \"2023-01-01\", \"2023-03-01\")),   fine = as.Date(c(\"2023-01-31\", \"2023-02-14\", \"2023-03-31\", \"2023-04-30\",                    \"2023-02-28\", \"2023-03-31\")),   arco = c(1, 0, 1, 1, 1, 0),   prior = c(1, 0, 0.5, 1, 1, 0),   over_id = c(1, 0, 2, 3, 1, 0),   contract_type = c(\"FT\", NA, \"PT\", \"FT\", \"FT\", NA),   salary = c(3000, NA, 1500, 3200, 2800, NA) )  # Complete consolidation (overlapping then consecutive) result_both <- merge_consecutive_employment(dt, consolidation_type = \"both\")  # Only merge overlapping contracts (same over_id > 0) result_overlapping <- merge_consecutive_employment(dt, consolidation_type = \"overlapping\")  # Only merge consecutive periods (traditional approach) result_consecutive <- merge_consecutive_employment(dt, consolidation_type = \"consecutive\")  # No consolidation (return original) result_none <- merge_consecutive_employment(dt, consolidation_type = \"none\") } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast.html","id":null,"dir":"Reference","previous_headings":"","what":"Alternative Fast Implementation Using Event-Based Approach — merge_consecutive_employment_fast","title":"Alternative Fast Implementation Using Event-Based Approach — merge_consecutive_employment_fast","text":"faster implementation inspired vecshift's event-based mechanism collapsing consecutive employment periods.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Alternative Fast Implementation Using Event-Based Approach — merge_consecutive_employment_fast","text":"","code":"merge_consecutive_employment_fast(dt)"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Alternative Fast Implementation Using Event-Based Approach — merge_consecutive_employment_fast","text":"dt data.table output vecshift()","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Alternative Fast Implementation Using Event-Based Approach — merge_consecutive_employment_fast","text":"data.table collapsed consecutive employment periods","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast_with_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Fast consolidation with consolidation_type support — merge_consecutive_employment_fast_with_type","title":"Fast consolidation with consolidation_type support — merge_consecutive_employment_fast_with_type","text":"High-performance version merge_consecutive_employment consolidation_type support","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast_with_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fast consolidation with consolidation_type support — merge_consecutive_employment_fast_with_type","text":"","code":"merge_consecutive_employment_fast_with_type(dt, consolidation_type = \"both\")"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast_with_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fast consolidation with consolidation_type support — merge_consecutive_employment_fast_with_type","text":"dt data.table object vecshift() output consolidation_type Character string specifying consolidation approach: \"\": Consolidate overlapping (over_id > 0) consecutive periods \"overlapping\": consolidate periods over_id > 0 \"consecutive\": consolidate consecutive periods (traditional approach) \"none\": consolidation, just add collapsed column return","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_consecutive_employment_fast_with_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fast consolidation with consolidation_type support — merge_consecutive_employment_fast_with_type","text":"data.table consolidated periods","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_original_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Original Data Columns with Temporal Segments — merge_original_columns","title":"Merge Original Data Columns with Temporal Segments — merge_original_columns","text":"Enriches vecshift output merging additional columns original contract data. function allows carry forward metadata additional attributes original employment contracts temporal segments created vecshift().","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_original_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Original Data Columns with Temporal Segments — merge_original_columns","text":"","code":"merge_original_columns(original_data, segments, columns)"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_original_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Original Data Columns with Temporal Segments — merge_original_columns","text":"original_data data.table containing original contract records processed vecshift(). Must include 'id' column columns specified 'columns' parameter. segments data.table containing output vecshift(). Must include 'id' column merging. columns Character vector specifying columns original_data merge segments. Column names must exist original_data.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_original_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Original Data Columns with Temporal Segments — merge_original_columns","text":"data.table combining segments data requested columns   original_data. temporal ordering structure segments   preserved. Unemployment periods (id = 0) included without   merged columns.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_original_columns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge Original Data Columns with Temporal Segments — merge_original_columns","text":"function performs inner join segments data original contract data using 'id' column key. Since vecshift() creates multiple temporal segments single contracts, original contract data may appear multiple segment rows. Unemployment periods (id = 0) preserved merged columns original data, correspond specific contracts.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_original_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge Original Data Columns with Temporal Segments — merge_original_columns","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table)  # Create sample employment data with additional metadata original_dt <- data.table(   id = 1:3,   cf = c(\"ABC123\", \"ABC123\", \"DEF456\"),   INIZIO = as.Date(c(\"2023-01-01\", \"2023-06-01\", \"2023-02-01\")),   FINE = as.Date(c(\"2023-05-31\", \"2023-12-31\", \"2023-11-30\")),   prior = c(1, 0, 1),   company = c(\"CompanyA\", \"CompanyB\", \"CompanyC\"),   salary = c(50000, 25000, 60000),   department = c(\"IT\", \"HR\", \"Finance\") )  # Transform to temporal segments segments <- vecshift(original_dt)  # Merge additional columns enriched <- merge_original_columns(   original_data = original_dt,   segments = segments,   columns = c(\"company\", \"salary\", \"department\") )  print(enriched)  # Merge single column with_company <- merge_original_columns(   original_data = original_dt,   segments = segments,   columns = \"company\" ) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_overlapping_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","title":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","text":"Processes merged segment data handle overlapping employment periods (arco > 1) combining values previous row according data type-specific rules. function operates output merge_original_columns() handles merging logic overlapping employment scenarios.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_overlapping_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","text":"","code":"merge_overlapping_values(segments_with_columns, columns)"},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_overlapping_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","text":"segments_with_columns data.table containing output merge_original_columns(), includes temporal segments merged columns. Must contain 'cf', 'arco' columns ordered person time. columns Character vector specifying columns process overlapping periods. columns must exist segments_with_columns.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_overlapping_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","text":"data.table structure input, overlapping   period values merged according data type rules. columns   rows remain unchanged.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_overlapping_values.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","text":"employment periods overlap (arco > 1), function combines values previous row current row based data type: Character/Factor columns: Values combined \"->\" separator         showing transitions (e.g., \"CompanyA->CompanyB\") Numeric columns: Values summed (e.g., overlapping salaries) Multiple overlaps (arco > 2): Chain values sequence         characters, continue summing numerics Factors: Converted character processing function processes rows sequentially within person (cf), looking previous row's value arco > 1 merging accordingly. arco = 1 0, values remain unchanged.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/merge_overlapping_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge Overlapping Values for Employment Periods — merge_overlapping_values","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table)  # Create sample employment data with overlapping periods original_dt <- data.table(   id = 1:3,   cf = c(\"PERSON001\", \"PERSON001\", \"PERSON001\"),   INIZIO = as.Date(c(\"2023-01-01\", \"2023-04-01\", \"2023-06-01\")),   FINE = as.Date(c(\"2023-06-30\", \"2023-08-31\", \"2023-12-31\")),   prior = c(1, 1, 0),   company = c(\"CompanyA\", \"CompanyB\", \"CompanyC\"),   salary = c(50000, 30000, 25000) )  # Transform to segments and merge columns segments <- vecshift(original_dt) with_columns <- merge_original_columns(original_dt, segments, c(\"company\", \"salary\"))  # Handle overlapping values result <- merge_overlapping_values(with_columns, c(\"company\", \"salary\")) print(result) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_quality_report.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Employment Quality Report — print.employment_quality_report","title":"Print Employment Quality Report — print.employment_quality_report","text":"Formats prints comprehensive data quality report recommendations data improvement.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_quality_report.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Employment Quality Report — print.employment_quality_report","text":"","code":"# S3 method for class 'employment_quality_report' print(x, ...)"},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_quality_report.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Employment Quality Report — print.employment_quality_report","text":"x employment_quality_report object ... Additional arguments (ignored)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_status_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Employment Status Patterns Analysis — print.employment_status_patterns","title":"Print Employment Status Patterns Analysis — print.employment_status_patterns","text":"Print Employment Status Patterns Analysis","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_status_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Employment Status Patterns Analysis — print.employment_status_patterns","text":"","code":"# S3 method for class 'employment_status_patterns' print(x, ...)"},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_status_patterns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Employment Status Patterns Analysis — print.employment_status_patterns","text":"x employment_status_patterns object ... Additional arguments (ignored)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_status_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Employment Status Validation Results — print.employment_status_validation","title":"Print Employment Status Validation Results — print.employment_status_validation","text":"Print Employment Status Validation Results","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_status_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Employment Status Validation Results — print.employment_status_validation","text":"","code":"# S3 method for class 'employment_status_validation' print(x, ...)"},{"path":"https://gmontaletti.github.io/vecshift/reference/print.employment_status_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Employment Status Validation Results — print.employment_status_validation","text":"x employment_status_validation object ... Additional arguments (ignored)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":null,"dir":"Reference","previous_headings":"","what":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"optimized helper function chains together vecshift(), merge_original_columns(), merge_consecutive_employment() operations efficient memory usage performance. function provides complete pipeline raw employment contracts processed temporal segments merged original data period consolidation using over_id.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"","code":"process_employment_pipeline(   original_data,   apply_vecshift = TRUE,   merge_columns = NULL,   handle_overlaps = !is.null(merge_columns),   collapse_consecutive = TRUE,   consolidate_periods = TRUE,   consolidation_type = \"both\",   classify_status = TRUE,   status_rules = NULL,   validate_over_id = TRUE,   validate_functions = TRUE,   show_progress = TRUE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"original_data data.table containing employment contract records required columns: id: Contract identifier cf: Person identifier inizio: Contract start date fine: Contract end date prior: Employment type indicator apply_vecshift Logical. TRUE (default), applies vecshift transformation. Set FALSE input data already processed vecshift output. merge_columns Character vector column names merge original_data. Set NULL (default) skip column merging step. handle_overlaps Logical. TRUE (default merge_columns specified), processes overlapping employment values. applies merge_columns NULL. collapse_consecutive Logical. TRUE (default), collapses consecutive employment periods using over_id-based implementation. consolidate_periods Logical. TRUE (default), enables period consolidation collapse_consecutive TRUE. Passed merge_consecutive_employment(). consolidation_type Character. Consolidation strategy consolidate_periods TRUE: \"\" (default), \"overlapping\", \"consecutive\", \"none\". classify_status Logical. TRUE (default), applies employment status classification separate step vecshift transformation. status_rules Optional custom status rules status classification step. NULL, uses defaults. validate_over_id Logical. TRUE (default), validates over_id consistency duration invariant vecshift transformation. validate_functions Logical. TRUE (default), checks function availability execution provides informative error messages. show_progress Logical. TRUE (default), displays progress bar showing current processing step, percentage completion, estimated time remaining. Uses 'progress' package available, falls back utils::txtProgressBar simple messages available.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"data.table containing processed employment segments. exact structure   depends pipeline steps applied: Base vecshift output: cf, inizio, fine, arco, prior, id, durata, stato, over_id merged columns: Additional columns original_data period consolidation: collapsed, n_periods, aggregated values result also includes attributes: pipeline_steps: Logical vector applied steps validation_results: over_id duration validation results consolidation_stats: Statistics period consolidation (applied)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"function performs following operations sequence: vecshift(): Core temporal transformation create segments over_id classify_employment_status(): Applies employment status classification separate step (optional) Validation: Validates over_id consistency duration invariant merge_original_columns(): Merges additional columns original data (optional) merge_overlapping_values(): Handles overlapping employment values (optional) merge_consecutive_employment(): Consolidates periods using over_id (optional) function optimized memory efficiency : Using data.table's reference semantics minimize copying Avoiding intermediate object creation possible Allowing selective execution pipeline steps Gracefully handling missing functions fallback behavior","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"function automatically detects processing functions available gracefully handles missing dependencies. merge_original_columns() merge_consecutive_employment() available, corresponding steps skipped warning message. over_id functionality requires vecshift() output over_id column. over_id available, consolidation falls back traditional consecutive merging.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/process_employment_pipeline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Process Employment Data Through Complete Pipeline — process_employment_pipeline","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table)  # Create sample employment data with metadata employment_data <- data.table(   id = 1:4,   cf = c(\"PERSON001\", \"PERSON001\", \"PERSON001\", \"PERSON002\"),   inizio = as.Date(c(\"2023-01-01\", \"2023-04-01\", \"2023-07-01\", \"2023-02-01\")),   fine = as.Date(c(\"2023-03-31\", \"2023-06-30\", \"2023-12-31\", \"2023-11-30\")),   prior = c(1, 1, 0, 1),   company = c(\"CompanyA\", \"CompanyB\", \"CompanyC\", \"CompanyD\"),   salary = c(50000, 55000, 25000, 60000),   department = c(\"IT\", \"IT\", \"HR\", \"Finance\") )  # Complete pipeline with all steps and progress bar result_full <- process_employment_pipeline(   original_data = employment_data,   merge_columns = c(\"company\", \"salary\", \"department\"),   handle_overlaps = TRUE,   collapse_consecutive = TRUE,   consolidate_periods = TRUE,   consolidation_type = \"both\",   show_progress = TRUE ) print(result_full) print(attr(result_full, \"validation_results\"))  # Only vecshift transformation without progress bar result_basic <- process_employment_pipeline(   original_data = employment_data,   merge_columns = NULL,   collapse_consecutive = FALSE,   show_progress = FALSE )  # Pipeline with column merging but no consecutive collapsing result_merged <- process_employment_pipeline(   original_data = employment_data,   merge_columns = c(\"company\", \"salary\"),   collapse_consecutive = FALSE,   validate_over_id = TRUE )  # Process already-transformed vecshift output segments <- vecshift(employment_data) result_post <- process_employment_pipeline(   original_data = employment_data,   apply_vecshift = FALSE,   merge_columns = c(\"company\"),   collapse_consecutive = TRUE,   consolidation_type = \"overlapping\" ) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/standardize_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Standardize Column Names for Employment Data — standardize_columns","title":"Standardize Column Names for Employment Data — standardize_columns","text":"Maps custom column names standardized internal names used vecshift functions. Allows flexibility input data structure maintaining consistent processing.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/standardize_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standardize Column Names for Employment Data — standardize_columns","text":"","code":"standardize_columns(dt, column_map, validate = TRUE)"},{"path":"https://gmontaletti.github.io/vecshift/reference/standardize_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standardize Column Names for Employment Data — standardize_columns","text":"dt Input data.table employment records column_map Named list mapping standard names actual column names: id: Contract identifier column name (required) cf: Person identifier column name (required) inizio: Start date column name (required) fine: End date column name (required) prior: Employment type column name (required) validate Logical. TRUE, validates mapped columns","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/standardize_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standardize Column Names for Employment Data — standardize_columns","text":"Data.table standardized column names","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/standardize_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Standardize Column Names for Employment Data — standardize_columns","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) # Data with custom column names dt <- data.table(   contract_id = 1:3,   person_code = c(\"A001\", \"A001\", \"B002\"),   start_date = as.Date(c(\"2023-01-01\", \"2023-06-01\", \"2023-02-01\")),   end_date = as.Date(c(\"2023-05-31\", \"2023-12-31\", \"2023-11-30\")),   employment_type = c(1, 0, 1) )  # Define column mapping col_map <- list(   id = \"contract_id\",   cf = \"person_code\",    inizio = \"start_date\",   fine = \"end_date\",   prior = \"employment_type\" )  # Standardize column names standardized_dt <- standardize_columns(dt, col_map) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/status_labeling.html","id":null,"dir":"Reference","previous_headings":"","what":"Employment Status Classification Module — status_labeling","title":"Employment Status Classification Module — status_labeling","text":"Enhanced flexible employment status classification system temporal employment segments. Features sequence-based overlap labeling, flexible prior value mapping, customizable rules diverse business contexts.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/status_labeling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Employment Status Classification Module — status_labeling","text":"**Enhanced Capabilities (Version 1.0+)**: 1. **Flexible Prior Value System**: longer normalizes prior values 0/1.    Supports numeric employment type codes custom prior_labels mapping. 2. **Sequence-Based Overlap Labeling**: Creates descriptive labels overlapping    employment periods based chronological sequence employment types.    Example: overlapping periods prior values [0, 1, 2] become \"over_pt_ft_fixed\". 3. **Unknown Prior Handling**: Automatically handles unmapped prior values    using numeric representation (e.g., \"occ_7\" unknown prior value 7). 4. **Custom Business Logic**: Supports industry-specific employment type    classifications prior_labels parameter. 5. **Backward Compatibility**: Maintains full compatibility existing    vecshift workflows enabling new flexible features. **Core Functions**: - \\code\\linkclassify_employment_status: Main classification function enhanced flexibility - \\code\\linkget_default_status_rules: Returns default rules including flexible prior mappings - \\code\\linkcreate_custom_status_rules: Creates custom rules prior_labels support - \\code\\linkanalyze_status_patterns: Analyzes employment status patterns - \\code\\linkvalidate_status_classifications: Validates classification results **Usage Patterns**: - Use default rules standard employment analysis - Create custom prior_labels industry-specific employment type codes - Leverage sequence-based labeling complex overlapping employment analysis - Apply validation functions ensure classification integrity","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_duration_invariant.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Duration Calculation Invariant — validate_duration_invariant","title":"Validate Duration Calculation Invariant — validate_duration_invariant","text":"Validates mathematical invariant holds: person, sum(durata) equal (max(fine) - min(inizio) + 1). ensures duration calculations consistent.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_duration_invariant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Duration Calculation Invariant — validate_duration_invariant","text":"","code":"validate_duration_invariant(dt)"},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_duration_invariant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Duration Calculation Invariant — validate_duration_invariant","text":"dt Data.table cf, inizio, fine, durata columns","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_duration_invariant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Duration Calculation Invariant — validate_duration_invariant","text":"List duration validation results","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_employment_data_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Employment Data Types and Formats — validate_employment_data_types","title":"Validate Employment Data Types and Formats — validate_employment_data_types","text":"Performs comprehensive validation employment data types, formats, basic logical consistency. Throws errors critical issues warnings potential problems. Includes validation over_id duration calculation consistency.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_employment_data_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Employment Data Types and Formats — validate_employment_data_types","text":"","code":"validate_employment_data_types(   dt,   strict = FALSE,   validate_over_id = TRUE,   validate_duration = TRUE )"},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_employment_data_types.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Employment Data Types and Formats — validate_employment_data_types","text":"dt Data.table standardized employment columns strict Logical. TRUE, throws errors warnings validate_over_id Logical. TRUE, validates over_id column consistency validate_duration Logical. TRUE, validates duration calculation invariant","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_employment_data_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Employment Data Types and Formats — validate_employment_data_types","text":"Invisible validation results list","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_over_id_consistency.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate over_id Column Consistency — validate_over_id_consistency","title":"Validate over_id Column Consistency — validate_over_id_consistency","text":"Validates over_id values consistent employment/unemployment status overlapping periods share over_id.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_over_id_consistency.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate over_id Column Consistency — validate_over_id_consistency","text":"","code":"validate_over_id_consistency(dt)"},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_over_id_consistency.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate over_id Column Consistency — validate_over_id_consistency","text":"dt Data.table over_id arco columns","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_over_id_consistency.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate over_id Column Consistency — validate_over_id_consistency","text":"List over_id validation results","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_status_classifications.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Employment Status Classifications — validate_status_classifications","title":"Validate Employment Status Classifications — validate_status_classifications","text":"Validates consistency logical correctness employment status classifications, checking impossible combinations missing labels. Adapted enhanced flexible prior value system - validates patterns rather specific hardcoded values. Optimized large datasets.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_status_classifications.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Employment Status Classifications — validate_status_classifications","text":"","code":"validate_status_classifications(   classified_data,   rules = get_default_status_rules() )"},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_status_classifications.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Employment Status Classifications — validate_status_classifications","text":"classified_data Data.table employment segments status labels rules Classification rules used (validation reference, including prior_labels)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_status_classifications.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Employment Status Classifications — validate_status_classifications","text":"List validation results detected issues: is_valid: Overall validation status validation_rate: Proportion valid classifications missing_labels: Count missing status labels impossible_combinations: Detailed breakdown logical errors unexpected_statuses: Status labels match expected patterns missing_critical_statuses: Critical status types missing","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_status_classifications.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Validate Employment Status Classifications — validate_status_classifications","text":"**Enhanced Validation Flexible Prior Values**: validation updated accommodate flexible prior value system: - longer validates specific prior values (since can numeric code) - Focuses structural consistency arco stato patterns - Validates status labels follow expected patterns (disoccupato, occ_, over_) - Checks missing critical status types rather exact label matches - Supports custom prior_labels rules parameter validation **Validation Checks**: - Missing empty status labels - Impossible combinations (e.g., unemployment arco > 0) - Structural inconsistencies employment counts status patterns - Unexpected status label formats - Missing critical status categories","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/validate_status_classifications.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Employment Status Classifications — validate_status_classifications","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) # Sample classified data with flexible prior values classified_data <- data.table(   cf = rep(\"A001\", 4),   inizio = 1:4,   fine = 2:5,   arco = c(0, 1, 2, 1),   prior = c(NA, 2, 5, 1),  # Includes unmapped value 5   durata = rep(1, 4),   stato = c(\"disoccupato\", \"occ_fixed\", \"over_5_ft\", \"occ_ft\") )  # Validate with default rules validation <- validate_status_classifications(classified_data) print(validation$is_valid) print(validation$validation_rate)  # Check for any issues if (!validation$is_valid) {   print(validation$impossible_combinations)   print(validation$unexpected_statuses) }  # Validate with custom rules that map prior value 5 custom_rules <- create_custom_status_rules(   prior_labels = list(\"1\" = \"ft\", \"2\" = \"fixed\", \"5\" = \"intern\") ) validation_custom <- validate_status_classifications(classified_data, custom_rules) print(validation_custom$is_valid) } # }"},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"Processes employment contract records temporal boundaries create continuous temporal segments track employment status time. core function handles event-based transformation logic, identifying unemployment periods (contracts active), single employment periods, overlapping employment situations.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"","code":"vecshift(dt)"},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"dt data.table containing employment contract records following required columns: id: Contract identifier (unique key employment contract) cf: Person identifier (e.g., fiscal code) inizio: Contract start date (Date numeric) fine: Contract end date (Date numeric) prior: Employment type indicator (0 negative part-time, positive full-time)","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"data.table temporal segments containing: cf: Person identifier inizio: Segment start date fine: Segment end date arco: Number overlapping contracts (0 = unemployment) prior: Employment type segment (0 = part-time, 1 = full-time) id: Contract ID (0 unemployment periods) durata: Duration segment days","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"function implements precise date logic temporal processing: Employment contracts inclusive start end dates person works inizio fine dates End events created fine date Unemployment periods identified (arco=0) adjusted: inizio+1 fine-1 ensures correct temporal boundaries segments algorithm creates events contract start (+1) end (-1 fine), uses cumulative sums track overlapping contracts. Unemployment segments identified (arco=0) dates adjusted represent actual unemployment period.","code":""},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"function performs core temporal transformation. employment status classification, use classify_employment_status separately use process_employment_pipeline complete processing pipeline.","code":""},{"path":[]},{"path":"https://gmontaletti.github.io/vecshift/reference/vecshift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform Employment Records into Temporal Segments (Core Function) — vecshift","text":"","code":"if (FALSE) { # \\dontrun{ library(data.table) # Create sample employment data dt <- data.table(   id = 1:3,   cf = c(\"ABC123\", \"ABC123\", \"DEF456\"),   inizio = as.Date(c(\"2023-01-01\", \"2023-06-01\", \"2023-02-01\")),   fine = as.Date(c(\"2023-05-31\", \"2023-12-31\", \"2023-11-30\")),   prior = c(1, 0, 1)  # 1 = full-time, 0 = part-time )  # Transform to temporal segments (pure transformation) result <- vecshift(dt) print(result)  # Apply status classification separately result_with_status <- classify_employment_status(result) print(result_with_status)  # Use complete pipeline for integrated processing result_pipeline <- process_employment_pipeline(dt) print(result_pipeline) } # }"}]
