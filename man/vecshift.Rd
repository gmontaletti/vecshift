% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vecshift.R
\name{vecshift}
\alias{vecshift}
\title{Transform Employment Records into Temporal Segments (Core Function)}
\usage{
vecshift(dt, classify_status = TRUE, status_rules = NULL)
}
\arguments{
\item{dt}{A data.table containing employment contract records with the following required columns:
\itemize{
  \item{\code{id}}: Contract identifier (unique key for each employment contract)
  \item{\code{cf}}: Person identifier (e.g., fiscal code)
  \item{\code{INIZIO}}: Contract start date (Date or numeric)
  \item{\code{FINE}}: Contract end date (Date or numeric)
  \item{\code{prior}}: Employment type indicator (0 or negative for part-time, positive for full-time)
}}

\item{classify_status}{Logical. If TRUE (default), applies employment status classification.
Set to FALSE to return raw segments without status labels.}

\item{status_rules}{Optional custom status classification rules. If NULL (default),
uses standard classification. See \code{\link{get_default_status_rules}} for structure.}
}
\value{
A data.table with temporal segments containing:
  \itemize{
    \item{\code{cf}}: Person identifier
    \item{\code{inizio}}: Segment start date
    \item{\code{fine}}: Segment end date
    \item{\code{arco}}: Number of overlapping contracts (0 = unemployment)
    \item{\code{prior}}: Employment type for the segment (0 = part-time, 1 = full-time)
    \item{\code{id}}: Contract ID (0 for unemployment periods)
    \item{\code{durata}}: Duration of the segment in days
    \item{\code{stato}}: Employment status classification (if classify_status = TRUE)
  }
}
\description{
Processes employment contract records with temporal boundaries to create
continuous temporal segments that track employment status over time. This core
function handles the event-based transformation logic, identifying unemployment
periods (when no contracts are active), single employment periods, and overlapping
employment situations.
}
\details{
The function implements precise date logic for temporal processing:
\itemize{
  \item Employment contracts are inclusive of both start and end dates
  \item A person works ON both INIZIO and FINE dates
  \item End events are created at FINE date
  \item Unemployment periods are identified (arco=0) and adjusted: inizio+1 and fine-1
  \item This ensures correct temporal boundaries for all segments
}

The algorithm creates events for each contract start (+1) and end (-1 at FINE), then uses
cumulative sums to track overlapping contracts. Unemployment segments are identified
(arco=0) and their dates are adjusted to represent the actual unemployment period.
}
\note{
Status classification is delegated to the \code{\link{classify_employment_status}}
function from the status_labeling module, ensuring consistent and customizable
employment status attribution across the package.
}
\examples{
\dontrun{
library(data.table)
# Create sample employment data
dt <- data.table(
  id = 1:3,
  cf = c("ABC123", "ABC123", "DEF456"),
  INIZIO = as.Date(c("2023-01-01", "2023-06-01", "2023-02-01")),
  FINE = as.Date(c("2023-05-31", "2023-12-31", "2023-11-30")),
  prior = c(1, 0, 1)  # 1 = full-time, 0 = part-time
)

# Transform to temporal segments with status classification
result <- vecshift(dt)
print(result)

# Transform without status classification
result_raw <- vecshift(dt, classify_status = FALSE)
print(result_raw)

# Use custom status rules
custom_rules <- create_custom_status_rules(
  unemployment_threshold = 30,
  custom_labels = list(unemployed_short = "seeking_job")
)
result_custom <- vecshift(dt, status_rules = custom_rules)
}
}
\seealso{
\code{\link{classify_employment_status}} for status classification details
\code{\link{get_default_status_rules}} for default classification rules
\code{\link{create_custom_status_rules}} for creating custom rules
}
